/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/scripts/banano-util.js":
/*!************************************!*\
  !*** ./app/scripts/banano-util.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst blake = __webpack_require__(/*! blakejs */ \"./node_modules/blakejs/index.js\");\n\nconst nacl = __webpack_require__(/*! ../../libraries/tweetnacl/nacl.js */ \"./libraries/tweetnacl/nacl.js\");\n\nconst workMin = BigInt('0xfffffe0000000000');\n\nconst preamble = '0000000000000000000000000000000000000000000000000000000000000006';\n\nconst banoshiDivisor = BigInt('1000000000000000000000000000');\n\nconst bananoDivisor = BigInt('100000000000000000000000000000');\n\nconst ACCOUNT_ALPHABET_REGEX_STR = '^[13456789abcdefghijkmnopqrstuwxyz]+$';\n\nconst SEED_ALPHABET_REGEX_STR = '^[0123456789abcdefABCDEF]{64}$';\n\nconst LOG_SEND = false;\n\nconst LOG_SEND_PROCESS = false;\n\nconst LOG_RECEIVE = false;\n\nconst LOG_OPEN = false;\n\nconst LOG_CHANGE = false;\n\nconst LOG_IS_WORK_VALID = false;\n\nconst LOG_GET_HASH_CPU_WORKER = false;\n\n/**\n * Converts a banano amount into a raw amount.\n *\n * @memberof BananoUtil\n * @param {string} bananoStr the banano, as a string.\n * @return {string} the banano as a raw value.\n */\nconst getRawStrFromBananoStr = (bananoStr) => {\n  /* istanbul ignore if */\n  if (bananoStr == undefined) {\n    throw Error( 'bananoStr is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if (typeof bananoStr !== 'string') {\n    throw Error(`'${bananoStr}' is not a string.`);\n  }\n  const decimalPlace = bananoStr.indexOf('.');\n  let divisor = BigInt('1');\n  // console.log('STARTED getRawStrFromBananoStr', bananoStr, decimalPlace, divisor);\n  if (decimalPlace !== -1) {\n    bananoStr = bananoStr.replace('.', '');\n    const decimalsAfter = bananoStr.length - decimalPlace;\n    // console.log('INTERIM getRawStrFromBananoStr decimalsAfter', decimalsAfter);\n    divisor = BigInt('10') ** BigInt(decimalsAfter);\n  }\n  // console.log('INTERIM getRawStrFromBananoStr', bananoStr, decimalPlace, divisor);\n  const banano = BigInt(bananoStr);\n  // console.log('INTERIM getRawStrFromBananoStr banano   ', banano);\n  // console.log('INTERIM getRawStrFromBananoStr bananoDiv', bananoDivisor);\n  const bananoRaw = (banano * bananoDivisor) / divisor;\n  // console.log('INTERIM getRawStrFromBananoStr bananoRaw', bananoRaw);\n  // const parts = getBananoPartsFromRaw(bananoRaw.toString());\n  // console.log('SUCCESS getRawStrFromBananoStr', bananoStr, bananoRaw, parts);\n  return bananoRaw.toString();\n};\n\n/**\n * Converts a banoshi amount into a raw amount.\n *\n * @memberof BananoUtil\n * @param {string} banoshiStr the banoshi, as a string.\n * @return {string} the banano as a raw value.\n */\nconst getRawStrFromBanoshiStr = (banoshiStr) => {\n  const banoshi = BigInt(banoshiStr);\n  const bananoRaw = banoshi * banoshiDivisor;\n  return bananoRaw.toString();\n};\n\n/**\n * @typedef {Object} BananoParts\n * @property {string} banano - The amount of banano.\n * @property {string} banoshi - The amount of banoshi (not counting whole banano).\n * @property {string} raw - The amount of raw (not counting whole banano and whole banoshi).\n */\n\n/**\n * Get the banano parts (banano, banoshi, raw) for a given raw value.\n *\n * @memberof BananoUtil\n * @param {string} bananoRawStr the raw banano, as a string.\n * @return {BananoParts} the banano parts.\n */\nconst getBananoPartsFromRaw = (bananoRawStr) => {\n  const bananoRaw = BigInt(bananoRawStr);\n  //    console.log(`bananoRaw:    ${bananoRaw}`);\n  //    console.log(`bananoDivisor:   ${bananoDivisor}`);\n  const banano = bananoRaw / bananoDivisor;\n  //    console.log(`banano:${banano}`);\n  const bananoRawRemainder = bananoRaw - (banano * bananoDivisor);\n  const banoshi = bananoRawRemainder / banoshiDivisor;\n  const banoshiRawRemainder = bananoRawRemainder - (banoshi * banoshiDivisor);\n\n  const bananoParts = {};\n  bananoParts.banano = banano.toString();\n  bananoParts.banoshi = banoshi.toString();\n  bananoParts.raw = banoshiRawRemainder.toString();\n  return bananoParts;\n};\n\nconst hexToBytes = (hex) => {\n  const ret = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < ret.length; i++) {\n    ret[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16);\n  }\n  return ret;\n};\n\nconst bytesToHex = (bytes) => {\n  return Buffer.from(bytes).toString('hex').toUpperCase();\n};\n\nconst hash = (block) => {\n  /* istanbul ignore if */\n  if (block === undefined) {\n    throw Error('block is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (block.account === undefined) {\n    throw Error('block.account is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (block.previous === undefined) {\n    throw Error('block.previous is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (block.representative === undefined) {\n    throw Error('block.representative is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (block.balance === undefined) {\n    throw Error('block.balance is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (block.link === undefined) {\n    throw Error('block.link is a required parameter.');\n  }\n  const context = blake.blake2bInit(32, null);\n  blake.blake2bUpdate(context, hexToBytes(preamble));\n  blake.blake2bUpdate(context, hexToBytes(getAccountPublicKey(block.account)));\n  blake.blake2bUpdate(context, hexToBytes(block.previous));\n  blake.blake2bUpdate(context, hexToBytes(getAccountPublicKey(block.representative)));\n\n  // console.log( `block.balance:${block.balance}` );\n  let balanceToPad = BigInt(block.balance).toString(16);\n  // console.log( `pre  balanceToPad:${balanceToPad}` );\n  while (balanceToPad.length < 32) {\n    balanceToPad = '0' + balanceToPad;\n  }\n  // console.log( `post balanceToPad:${balanceToPad}` );\n  const balance = hexToBytes(balanceToPad);\n  // console.log( `balance:${balance}` );\n  blake.blake2bUpdate(context, balance);\n  blake.blake2bUpdate(context, hexToBytes(block.link));\n  const hash = bytesToHex(blake.blake2bFinal(context));\n  return hash;\n};\n\nconst uint5ToUint4 = (uint5) => {\n  const length = uint5.length / 4 * 5;\n  const uint4 = new Uint8Array(length);\n  for (let i = 1; i <= length; i++) {\n    const n = i - 1;\n    const m = i % 5;\n    const z = n - ((i - m) / 5);\n    const right = uint5[z - 1] << (5 - m);\n    const left = uint5[z] >> m;\n    uint4[n] = (left + right) % 16;\n  }\n  return uint4;\n};\n\nconst array_crop = (array) => {\n  const length = array.length - 1;\n  const cropped_array = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    cropped_array[i] = array[i + 1];\n  }\n  return cropped_array;\n};\n\nconst uint4ToHex = (uint4) => {\n  let hex = '';\n  for (let i = 0; i < uint4.length; i++) {\n    hex += uint4[i].toString(16).toUpperCase();\n  }\n  return hex;\n};\n\nconst uint8ToUint4 = (uintValue) => {\n  const uint4 = new Uint8Array(uintValue.length * 2);\n  for (let i = 0; i < uintValue.length; i++) {\n    uint4[i * 2] = uintValue[i] / 16 | 0;\n    uint4[i * 2 + 1] = uintValue[i] % 16;\n  }\n\n  return uint4;\n};\n\nconst equal_arrays = (array1, array2) => {\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] != array2[i]) return false;\n  }\n  return true;\n};\n\nconst uint4ToUint8 = (uintValue) => {\n  const length = uintValue.length / 2;\n  const uint8 = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    uint8[i] = (uintValue[i * 2] * 16) + uintValue[i * 2 + 1];\n  }\n\n  return uint8;\n};\n\nconst stringToUint5 = (string) => {\n  const letter_list = '13456789abcdefghijkmnopqrstuwxyz'.split('');\n  const length = string.length;\n  const string_array = string.split('');\n  const uint5 = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    uint5[i] = letter_list.indexOf(string_array[i]);\n  }\n  return uint5;\n};\n\nconst isAccountSuffixValid = (accountSuffix) => {\n  const regex = new RegExp(ACCOUNT_ALPHABET_REGEX_STR);\n  const isValid = regex.test(accountSuffix);\n  const retval = {};\n  retval.valid = isValid;\n  if (isValid) {\n    retval.message = '';\n  } else {\n    retval.message = `does not match regex '${ACCOUNT_ALPHABET_REGEX_STR}'`;\n  }\n  return retval;\n};\n\n/**\n * Get the public key for a given account.\n *\n * @memberof BananoUtil\n * @param {string} account the account.\n * @return {string} the public key.\n */\nconst getAccountPublicKey = (account) => {\n  if (account === undefined) {\n    throw Error(`Undefined BANANO Account`);\n  }\n  let account_crop;\n  if (account.startsWith('camo')) {\n    if (((!account.startsWith('camo_1')) &&\n        (!account.startsWith('camo_3'))) ||\n        (account.length !== 65)) {\n      throw Error(`Invalid CAMO BANANO Account prefix '${account}'`);\n    }\n    account_crop = account.substring(5, 65);\n  } else {\n    if (((!account.startsWith('ban_1')) &&\n        (!account.startsWith('ban_3'))) ||\n        (account.length !== 64)) {\n      throw Error(`Invalid BANANO Account prefix '${account}'`);\n    }\n    account_crop = account.substring(4, 64);\n  }\n  const isAccountValid = isAccountSuffixValid(account_crop);\n  if (!isAccountValid.valid) {\n    throw Error(`Invalid BANANO Account '${account}', ${isAccountValid.message}`);\n  }\n\n  const key_uint4 = array_crop(uint5ToUint4(stringToUint5(account_crop.substring(0, 52))));\n  const hash_uint4 = uint5ToUint4(stringToUint5(account_crop.substring(52, 60)));\n  const key_array = uint4ToUint8(key_uint4);\n  const blake_hash = blake.blake2b(key_array, null, 5).reverse();\n\n  const left = hash_uint4;\n  const right = uint8ToUint4(blake_hash);\n  if (!equal_arrays(left, right)) {\n    const leftStr = uint5ToString(uint4ToUint5(left));\n    const rightStr = uint5ToString(uint4ToUint5(right));\n\n    throw Error(`Incorrect checksum ${leftStr} <> ${rightStr}`);\n  }\n\n  return uint4ToHex(key_uint4);\n};\n\nconst hexToUint8 = (hexValue) => {\n  const length = (hexValue.length / 2) | 0;\n  const uint8 = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    uint8[i] = parseInt(hexValue.substr(i * 2, 2), 16);\n  }\n  return uint8;\n};\n\nconst decToHex = (decValue, bytes = null) => {\n  const dec = decValue.toString().split('');\n  const sum = [];\n  let hex = '';\n  const hexArray = [];\n  let i; let s;\n  while (dec.length) {\n    s = 1 * dec.shift();\n    for (i = 0; s || i < sum.length; i++) {\n      s += (sum[i] || 0) * 10;\n      sum[i] = s % 16;\n      s = (s - sum[i]) / 16;\n    }\n  }\n  while (sum.length) {\n    hexArray.push(sum.pop().toString(16));\n  }\n\n  hex = hexArray.join('');\n\n  if (hex.length % 2 != 0) {\n    hex = '0' + hex;\n  }\n\n  if (bytes > hex.length / 2) {\n    const diff = bytes - hex.length / 2;\n    for (let j = 0; j < diff; j++) {\n      hex = '00' + hex;\n    }\n  }\n\n  return hex;\n};\n\n\nconst generateAccountSecretKeyBytes = (seedBytes, accountIndex) => {\n  const accountBytes = hexToUint8(decToHex(accountIndex, 4));\n  const context = blake.blake2bInit(32);\n  blake.blake2bUpdate(context, seedBytes);\n  blake.blake2bUpdate(context, accountBytes);\n  const newKey = blake.blake2bFinal(context);\n  return newKey;\n};\n\nconst uint4ToUint5 = (uintValue) => {\n  const length = uintValue.length / 5 * 4;\n  const uint5 = new Uint8Array(length);\n  for (let i = 1; i <= length; i++) {\n    const n = i - 1;\n    const m = i % 4;\n    const z = n + ((i - m) / 4);\n    const right = uintValue[z] << m;\n    let left;\n    if (((length - i) % 4) == 0) {\n      left = uintValue[z - 1] << 4;\n    } else {\n      left = uintValue[z + 1] >> (4 - m);\n    }\n    uint5[n] = (left + right) % 32;\n  }\n  return uint5;\n};\n\n\n/**\n * Get the account suffix for a given public key (everything but ban_ or camo_).\n *\n * @memberof BananoUtil\n * @param {string} publicKey the public key.\n * @return {string} the account suffix.\n */\nconst getAccountSuffix = (publicKey) => {\n  const keyBytes = uint4ToUint8(hexToUint4(publicKey)); // For some reason here we go from u, to hex, to 4, to 8??\n  const checksum = uint5ToString(uint4ToUint5(uint8ToUint4(blake.blake2b(keyBytes, null, 5).reverse())));\n  const account = uint5ToString(uint4ToUint5(hexToUint4(`0${publicKey}`)));\n  return `${account}${checksum}`;\n};\n\n/**\n * Get the account for a given public key.\n *\n * @memberof BananoUtil\n * @param {string} publicKey the public key.\n * @return {string} the account.\n */\nconst getAccount = (publicKey) => {\n  const accountSuffix = getAccountSuffix(publicKey);\n  return `ban_${accountSuffix}`;\n};\n\nconst uint5ToString = (uint5) => {\n  const letter_list = '13456789abcdefghijkmnopqrstuwxyz'.split('');\n  let string = '';\n  for (let i = 0; i < uint5.length; i++) {\n    string += letter_list[uint5[i]];\n  }\n\n  return string;\n};\n\nconst hexToUint4 = (hexValue) => {\n  const uint4 = new Uint8Array(hexValue.length);\n  for (let i = 0; i < hexValue.length; i++) {\n    uint4[i] = parseInt(hexValue.substr(i, 1), 16);\n  }\n\n  return uint4;\n};\n\nconst sign = (privateKey, block) => {\n  //    console.log( `sign ${JSON.stringify( block )}` );\n  const hashBytes = hexToBytes(hash(block));\n  //    console.log( `hashBytes[${hashBytes.length}]:${hashBytes}` );\n\n  const privateKeyBytes = hexToBytes(privateKey);\n  //    console.log( `privateKeyBytes[${privateKeyBytes.length}]:${privateKeyBytes}` );\n\n  const signed = nacl.sign.detached(hashBytes, privateKeyBytes);\n  const signature = bytesToHex(signed);\n  return signature;\n};\n\nconst generateAccountKeyPair = (accountSecretKeyBytes) => {\n  return nacl.sign.keyPair.fromSecretKey(accountSecretKeyBytes);\n};\n\n/**\n * returns true if the work (in bytes) for the hash (in bytes) is valid.\n *\n * @memberof BananoUtil\n * @param {string} hashBytes the hash bytes to check.\n * @param {string} workBytes the work bytes to check.\n * @return {boolean} true if the work is valid for the hash.\n */\nconst isWorkValid = (hashBytes, workBytes) => {\n  const context = blake.blake2bInit(8);\n  blake.blake2bUpdate(context, workBytes);\n  blake.blake2bUpdate(context, hashBytes);\n  const output = blake.blake2bFinal(context).reverse();\n  const outputHex = bytesToHex(output);\n  const outputBigInt = BigInt('0x' + outputHex);\n\n  const retval = outputBigInt >= workMin;\n\n  /* istanbul ignore if */\n  if (LOG_IS_WORK_VALID) {\n    console.log(`isWorkValid ${outputBigInt} >= ${workMin} ? ${retval}`);\n  }\n\n  return retval;\n};\n\nconst incrementBytes = (bytes) => {\n  let x = bytes.length - 1;\n  for (x; x >= 0; x--) {\n    if ( bytes[x] ^ 0xFF ) {\n      bytes[x]++;\n      return;\n    } else {\n      bytes[x] = 0;\n    }\n  }\n};\n\n/**\n * creates a new Uint8Array(8) to calculate work bytes.\n *\n * @memberof BananoUtil\n * @return {Uint8Array} the bytes in a Uint8Array.\n */\nconst getZeroedWorkBytes = () => {\n  return new Uint8Array(8);\n};\n\nconst getHashCPUWorker = (hash, workBytes) => {\n  /* istanbul ignore if */\n  if (LOG_GET_HASH_CPU_WORKER) {\n    console.log('STARTED getHashCPUWorker', hash, bytesToHex(startWorkBytes));\n  }\n  /* istanbul ignore if */\n  if (hash === undefined) {\n    throw Error('hash is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (workBytes === undefined) {\n    throw Error('workBytes is a required parameter.');\n  }\n  const hashBytes = hexToBytes(hash);\n\n  const startTime = process.hrtime.bigint();\n  let isWorkValidFlag = isWorkValid(hashBytes, workBytes);\n\n  let isWorkValidNanos = process.hrtime.bigint() - startTime;\n  let incrementBytesNanos = BigInt(0);\n\n  while (!isWorkValidFlag) {\n    const startTime0 = process.hrtime.bigint();\n    incrementBytes(workBytes);\n    incrementBytesNanos += process.hrtime.bigint() - startTime0;\n\n    const startTime1 = process.hrtime.bigint();\n    isWorkValidFlag = isWorkValid(hashBytes, workBytes);\n    isWorkValidNanos += process.hrtime.bigint() - startTime1;\n  }\n  const retval = bytesToHex(workBytes.reverse());\n  /* istanbul ignore if */\n  if (LOG_GET_HASH_CPU_WORKER) {\n    console.log('SUCCESS getHashCPUWorker', hash, bytesToHex(startWorkBytes), retval);\n  }\n  return retval;\n};\n\n\n/**\n * Get the public key for a given private key.\n *\n * @memberof BananoUtil\n * @param {string} privateKey the private key.\n * @return {string} the public key.\n */\nconst getPublicKey = (privateKey) => {\n  const accountKeyPair = generateAccountKeyPair(hexToBytes(privateKey));\n  return bytesToHex(accountKeyPair.publicKey);\n};\n\n/**\n * validates a seed.\n *\n * @memberof BananoUtil\n * @param {string} seed the seed to use to validate.\n * @param {string} seedIx the index to use with the seed.\n * @return {object} {valid:[true/false] message:[if false, why]}.\n */\nconst isSeedValid = (seed) => {\n  const regex = new RegExp(SEED_ALPHABET_REGEX_STR);\n  const isValid = regex.test(seed);\n  const retval = {};\n  retval.valid = isValid;\n  if (isValid) {\n    retval.message = '';\n  } else {\n    retval.message = `does not match regex '${SEED_ALPHABET_REGEX_STR}'`;\n  }\n  return retval;\n};\n\n/**\n * Get the private key for a given seed.\n *\n * @memberof BananoUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @return {string} the private key.\n */\nconst getPrivateKey = (seed, seedIx) => {\n  /* istanbul ignore if */\n  if (seed === undefined) {\n    throw Error('seed is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (seedIx === undefined) {\n    throw Error('seedIx is a required parameter.');\n  }\n  const isValid = isSeedValid(seed);\n  if (!isValid.valid) {\n    throw Error(`Invalid BANANO seed '${seed}', ${isValid.message}`);\n  }\n  const seedBytes = hexToBytes(seed);\n  const accountBytes = generateAccountSecretKeyBytes(seedBytes, seedIx);\n  return bytesToHex(accountBytes);\n};\n\nconst send = async (bananodeApi, seed, seedIx, destAccount, amountRaw, successCallback, failureCallback) => {\n  /* istanbul ignore if */\n  if (bananodeApi === undefined) {\n    throw Error('bananodeApi is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (seed === undefined) {\n    throw Error('privateKey is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (seedIx === undefined) {\n    throw Error('privateKey is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (destAccount === undefined) {\n    throw Error('destAccount is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (amountRaw === undefined) {\n    throw Error('amountRaw is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (successCallback === undefined) {\n    throw Error('successCallback is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (failureCallback === undefined) {\n    throw Error('failureCallback is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`STARTED send ${seed} ${seedIx}`);\n  }\n  const privateKey = getPrivateKey(seed, seedIx);\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`INTERIM send ${seed} ${seedIx} ${privateKey}`);\n  }\n  await sendFromPrivateKey(bananodeApi, privateKey, destAccount, amountRaw)\n      .then((hash) => {\n      /* istanbul ignore if */\n        if (LOG_SEND) {\n          console.log(`SUCCESS send ${seed} ${seedIx} ${hash}`);\n        }\n        successCallback(hash);\n      })\n      .catch((error) => {\n      /* istanbul ignore if */\n        if (LOG_SEND) {\n          console.log('FAILURE send', error);\n        }\n        failureCallback(error);\n      });\n};\n\nconst sendFromPrivateKey = async (bananodeApi, privateKey, destAccount, amountRaw) => {\n  return await sendFromPrivateKeyWithRepresentative(bananodeApi, privateKey, destAccount, amountRaw, undefined);\n};\n\nconst sendFromPrivateKeyWithRepresentative = async (bananodeApi, privateKey, destAccount, amountRaw, newRepresentative, newPrevious) => {\n  return await sendFromPrivateKeyWithRepresentativeAndPrevious(bananodeApi, privateKey, destAccount, amountRaw, newRepresentative, undefined);\n};\n\nconst sendFromPrivateKeyWithRepresentativeAndPrevious = async (bananodeApi, privateKey, destAccount, amountRaw, newRepresentative, newPrevious) => {\n  /* istanbul ignore if */\n  if (bananodeApi === undefined) {\n    throw Error('bananodeApi is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (privateKey === undefined) {\n    throw Error('privateKey is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (destAccount === undefined) {\n    throw Error('destAccount is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (amountRaw === undefined) {\n    throw Error('amountRaw is a required parameter.');\n  }\n  // newRepresentative is optional.\n  // newPrevious is optional.\n\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`STARTED sendFromPrivateKeyWithRepresentativeAndPrevious ${destAccount} ${amountRaw}`);\n  }\n\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`STARTED getPublicKey ${privateKey}`);\n  }\n  const publicKey = getPublicKey(privateKey);\n\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`STARTED getPublicAccountID ${publicKey}`);\n  }\n  const accountAddress = getAccount(publicKey);\n\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`STARTED getAccountInfo ${destAccount} ${amountRaw}`);\n  }\n\n  const accountInfo = await bananodeApi.getAccountInfo(accountAddress);\n  if (accountInfo == undefined) {\n    throw Error(`The server's account info cannot be retrieved, please try again.`);\n  }\n\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`SUCCESS getAccountInfo ${accountAddress} ${JSON.stringify(accountInfo)}`);\n  }\n\n  const balanceRaw = accountInfo.balance;\n\n  if (balanceRaw == undefined) {\n    throw Error(`The server's account balance cannot be retrieved, please try again.`);\n  }\n\n  if (BigInt(balanceRaw) < BigInt(amountRaw)) {\n    const balance = getBananoPartsFromRaw(balanceRaw);\n    const amount = getBananoPartsFromRaw(amountRaw);\n    //        console.log( `balance:${JSON.stringify( balance )}` );\n    throw Error(`The server's account balance of ${balance.banano} bananos is too small, cannot withdraw ${amount.banano} bananos.`);\n  }\n\n  const remaining = BigInt(balanceRaw) - BigInt(amountRaw);\n\n\n  const remainingDecimal = remaining.toString(10);\n  let remainingPadded = remaining.toString(16);\n  // Left pad with 0's\n  while (remainingPadded.length < 32) {\n    remainingPadded = '0' + remainingPadded;\n  }\n\n  let representative;\n  if (newRepresentative !== undefined) {\n    representative = newRepresentative;\n  } else {\n    representative = await bananodeApi.getAccountRepresentative(accountAddress);\n  }\n\n\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`INTERIM send representative ${representative}`);\n  }\n\n  let previous;\n  if (newPrevious !== undefined) {\n    previous = newPrevious;\n  } else {\n    previous = accountInfo.frontier;\n  }\n\n  /* istanbul ignore if */\n  if (LOG_SEND) {\n    console.log(`INTERIM send previous ${previous}`);\n  }\n\n  if (previous == '') {\n    /* istanbul ignore if */\n    if (LOG_SEND) {\n      console.log(`FAILURE previous == ''`);\n    }\n    return undefined;\n  } else {\n    const hashBytes = hexToBytes(previous);\n\n    const block = {};\n    block.type = 'state';\n    block.account = accountAddress;\n    block.previous = previous;\n    block.representative = representative;\n    block.balance = remainingDecimal;\n\n    /* istanbul ignore if */\n    if (LOG_SEND) {\n      console.log('STARTED getAccountPublicKey', destAccount);\n    }\n    block.link = getAccountPublicKey(destAccount);\n    /* istanbul ignore if */\n    if (LOG_SEND) {\n      console.log('SUCCESS getAccountPublicKey', destAccount);\n    }\n    /* istanbul ignore if */\n    if (LOG_SEND) {\n      console.log('STARTED sign');\n    }\n    block.signature = sign(privateKey, block);\n    /* istanbul ignore if */\n    if (LOG_SEND) {\n      console.log('SUCCESS sign');\n    }\n\n    /* istanbul ignore if */\n    if (LOG_SEND || LOG_SEND_PROCESS) {\n      console.log(`STARTED process`, block);\n    }\n    const processResponse = await bananodeApi.process(block);\n    /* istanbul ignore if */\n    if (LOG_SEND || LOG_SEND_PROCESS) {\n      console.log(`SUCCESS process`, processResponse);\n    }\n    return processResponse;\n  }\n};\n\nconst open = async (bananodeApi, privateKey, publicKey, representative, pending, pendingValueRaw) => {\n  const work = await bananodeApi.getGeneratedWork(publicKey);\n  const accountAddress = getAccount(publicKey);\n  const block = {};\n  block.type = 'state';\n  block.account = accountAddress;\n  block.previous = '0000000000000000000000000000000000000000000000000000000000000000';\n  block.representative = representative;\n  block.balance = pendingValueRaw;\n  block.link = pending;\n  block.work = work;\n  block.signature = sign(privateKey, block);\n\n  // console.log( 'open', block );\n\n  try {\n    const processResponse = await bananodeApi.process(block);\n    /* istanbul ignore if */\n    if (LOG_OPEN) {\n      console.log('SUCCESS open', processResponse);\n    }\n    return processResponse;\n  } catch (e) {\n    /* istanbul ignore if */\n    if (LOG_OPEN) {\n      console.log('FAILURE open', JSON.stringify(e));\n    }\n    throw Error(JSON.stringify(e));\n  }\n};\n\nconst change = async (bananodeApi, privateKey, representative) => {\n  /* istanbul ignore if */\n  if (bananodeApi === undefined) {\n    throw Error('bananodeApi is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (privateKey === undefined) {\n    throw Error('privateKey is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (representative === undefined) {\n    throw Error('representative is a required parameter.');\n  }\n  const publicKey = getPublicKey(privateKey);\n  const accountAddress = getAccount(publicKey);\n  const accountInfo = await bananodeApi.getAccountInfo(accountAddress);\n  /* istanbul ignore if */\n  if (accountInfo == undefined) {\n    throw Error(`The server's account info cannot be retrieved, please try again.`);\n  }\n  const previous = accountInfo.frontier;\n  const work = await bananodeApi.getGeneratedWork(previous);\n  const balanceRaw = accountInfo.balance;\n\n\n  /* istanbul ignore if */\n  if (balanceRaw == undefined) {\n    throw Error(`The server's account balance cannot be retrieved, please try again.`);\n  }\n\n  const remaining = BigInt(balanceRaw);\n\n  const remainingDecimal = remaining.toString(10);\n\n  const block = {};\n  block.type = 'state';\n  block.account = accountAddress;\n  block.previous = previous;\n  block.representative = representative;\n  block.balance = remainingDecimal;\n  block.link = '0000000000000000000000000000000000000000000000000000000000000000';\n  block.work = work;\n  block.signature = sign(privateKey, block);\n\n\n  /* istanbul ignore if */\n  if (LOG_CHANGE) {\n    console.log('STARTED change', block);\n  }\n  try {\n    const processResponse = await bananodeApi.process(block);\n    /* istanbul ignore if */\n    if (LOG_CHANGE) {\n      console.log('SUCCESS change', processResponse);\n    }\n    return processResponse;\n  } catch (e) {\n    /* istanbul ignore if */\n    if (LOG_RECEIVE) {\n      console.log('FAILURE receive', JSON.stringify(e));\n    }\n    throw Error(JSON.stringify(e));\n  }\n};\n\nconst receive = async (bananodeApi, privateKey, publicKey, representative, previous, hash, valueRaw) => {\n  /* istanbul ignore if */\n  if (bananodeApi === undefined) {\n    throw Error('bananodeApi is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (privateKey === undefined) {\n    throw Error('privateKey is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (publicKey === undefined) {\n    throw Error('publicKey is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (representative === undefined) {\n    throw Error('representative is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (previous === undefined) {\n    throw Error('previous is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (hash === undefined) {\n    throw Error('hash is a required parameter.');\n  }\n  /* istanbul ignore if */\n  if (valueRaw === undefined) {\n    throw Error('valueRaw is a required parameter.');\n  }\n  const work = await bananodeApi.getGeneratedWork(previous);\n  const accountAddress = getAccount(publicKey);\n\n  const block = {};\n  block.type = 'state';\n  block.account = accountAddress;\n  block.previous = previous;\n  block.representative = representative;\n  block.balance = valueRaw;\n  block.link = hash;\n  block.work = work;\n  block.signature = sign(privateKey, block);\n\n  /* istanbul ignore if */\n  if (LOG_RECEIVE) {\n    console.log('STARTED receive', block);\n  }\n  try {\n    const processResponse = await bananodeApi.process(block);\n    /* istanbul ignore if */\n    if (LOG_RECEIVE) {\n      console.log('SUCCESS receive', processResponse);\n    }\n    return processResponse;\n  } catch (e) {\n    /* istanbul ignore if */\n    if (LOG_RECEIVE) {\n      console.log('FAILURE receive', JSON.stringify(e));\n    }\n    throw Error(JSON.stringify(e));\n  }\n};\n\n\n/**\n * @typedef {Object} AccountValidationInfo\n * @property {string} message - The message describing why the account is valid or not.\n * @property {boolean} valid - True if account is valid.\n */\n\n/**\n  * Returns an object saying if the account is valid or not.\n\n  * If the account is not valid, the message describes why it is not valid.\n  *\n  * @memberof BananoUtil\n  * @param {string} account the account.\n  * @return {AccountValidationInfo} an object saying if the account is valid, and why.\n  */\nconst getAccountValidationInfo = (account) => {\n  if (account === null) {\n    return {\n      message: 'Invalid BANANO Account (null)',\n      valid: false,\n    };\n  }\n  if (account === undefined) {\n    return {\n      message: 'Invalid BANANO Account (undefined)',\n      valid: false,\n    };\n  }\n  if (account.length == 64) {\n    if (!account.startsWith('ban_1') && !account.startsWith('ban_3')) {\n      return {\n        message: 'Invalid BANANO Account (does not start with ban_1 or ban_3)',\n        valid: false,\n      };\n    }\n  } else {\n    return {\n      message: 'Invalid BANANO Account (not 64 characters)',\n      valid: false,\n    };\n  }\n  const account_crop = account.substring(4, 64);\n  const isValid = /^[13456789abcdefghijkmnopqrstuwxyz]+$/.test(account_crop);\n  if (!isValid) {\n    return {\n      message: `Invalid BANANO account (characters after ban_ must be one of:13456789abcdefghijkmnopqrstuwxyz)`,\n      valid: false,\n    };\n  };\n\n  try {\n    getAccountPublicKey(account);\n  } catch (error) {\n    return {\n      message: `Invalid BANANO account (${error.message})`,\n      valid: false,\n    };\n  }\n  return {\n    message: 'valid',\n    valid: true,\n  };\n};\n\nconst isAccountOpen = async (bananodeApi, account) => {\n  const history = await bananodeApi.getAccountHistory( account, 1 );\n  const history_history = history.history;\n  const history_history_length = history_history.length;\n  return history_history_length !== 0;\n};\n\nexports.decToHex = decToHex;\nexports.incrementBytes = incrementBytes;\nexports.getAccountValidationInfo = getAccountValidationInfo;\nexports.receive = receive;\nexports.open = open;\nexports.change = change;\nexports.getRawStrFromBanoshiStr = getRawStrFromBanoshiStr;\nexports.getRawStrFromBananoStr = getRawStrFromBananoStr;\nexports.getAccount = getAccount;\nexports.getPublicKey = getPublicKey;\nexports.getPrivateKey = getPrivateKey;\nexports.hash = hash;\nexports.sign = sign;\nexports.getAccountPublicKey = getAccountPublicKey;\nexports.send = send;\nexports.getHashCPUWorker = getHashCPUWorker;\nexports.getZeroedWorkBytes = getZeroedWorkBytes;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.isWorkValid = isWorkValid;\nexports.getBananoPartsFromRaw = getBananoPartsFromRaw;\nexports.sendFromPrivateKey = sendFromPrivateKey;\nexports.sendFromPrivateKeyWithRepresentative = sendFromPrivateKeyWithRepresentative;\nexports.sendFromPrivateKeyWithRepresentativeAndPrevious = sendFromPrivateKeyWithRepresentativeAndPrevious;\nexports.getAccountSuffix = getAccountSuffix;\nexports.isAccountSuffixValid = isAccountSuffixValid;\nexports.isAccountOpen = isAccountOpen;\nexports.isSeedValid = isSeedValid;\n\n\n//# sourceURL=webpack:///./app/scripts/banano-util.js?");

/***/ }),

/***/ "./app/scripts/bananode-api.js":
/*!*************************************!*\
  !*** ./app/scripts/bananode-api.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst request = __webpack_require__(/*! request */ \"request\");\n\nlet url;\n\nconst LOG_GET_GENERATED_WORK = false;\n\nconst sendRequest = async (formData) => {\n  if (formData == undefined) {\n    throw Error(`'formData' is a required parameter.`);\n  }\n  return new Promise((resolve) => {\n    // https://docs.nano.org/commands/rpc-protocol#accounts-balances\n\n    const body = JSON.stringify(formData);\n    //        console.log( 'sendRequest request', body );\n\n    request({\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      uri: url,\n      body: body,\n      method: 'POST',\n      timeout: 30000,\n    }, (err, httpResponse, body) => {\n      //            console.log( 'sendRequest response', err, body );\n\n      if (err !== null) {\n        console.log('sendRequest response', err, body);\n      }\n\n      if (body === undefined) {\n        resolve(undefined);\n      } else {\n        const json = JSON.parse(body);\n        resolve(json);\n      }\n    });\n  });\n};\n\nconst getAccountBalanceRaw = async (account) => {\n  if (account == undefined) {\n    throw Error(`'account' is a required parameter.`);\n  }\n  const formData = {\n    action: 'accounts_balances',\n    accounts: [account],\n  };\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      if (json == undefined) {\n        resolve();\n        return;\n      }\n      //            console.log( 'getAccountBalanceRaw json', json );\n      //            console.log( 'getAccountBalanceRaw json.balances', json.balances );\n\n      const balance = json.balances[account].balance;\n      //            console.log( 'getAccountBalanceRaw balance', balance );\n      resolve(balance);\n    });\n  });\n};\n\nconst getAccountRepresentative = async (account) => {\n  if (account == undefined) {\n    throw Error(`'account' is a required parameter.`);\n  }\n  // https://docs.nano.org/commands/rpc-protocol#account-representative\n  const formData = {\n    action: 'account_representative',\n    account: account,\n  };\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      if (json === undefined) {\n        resolve('');\n      } else {\n        const representative = json.representative;\n        resolve(representative);\n      }\n    });\n  });\n};\n\nconst getPrevious = async (account) => {\n  if (account == undefined) {\n    throw Error(`'account' is a required parameter.`);\n  }\n  // https://docs.nano.org/commands/rpc-protocol#frontiers\n  const formData = {\n    action: 'accounts_frontiers',\n    accounts: [account],\n    count: 1,\n  };\n  //    console.log( `getPrevious request ${account}` );\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      //            console.log( `getPrevious response ${JSON.stringify( json )}` );\n      if (json === undefined) {\n        resolve('');\n      } else if (json.frontiers == '') {\n        //                console.log( `getPrevious response ${account}` );\n        resolve('');\n      } else {\n        const previous = json.frontiers[account];\n        //                console.log( `getPrevious response ${account} ${previous}` );\n        resolve(previous);\n      }\n    });\n  });\n};\n\n\nconst getAccountHistory = async (account, count, head, raw) => {\n  if (account === undefined) {\n    throw Error(`'account' is a required parameter.`);\n  }\n  if (count === undefined) {\n    throw Error(`'count' is a required parameter.`);\n  }\n  // https://docs.nano.org/commands/rpc-protocol/#account_history\n  const formData = {\n    action: 'account_history',\n    account: account,\n    count: count,\n  };\n\n  if (head !== undefined) {\n    formData.head = head;\n  }\n\n  if (raw !== undefined) {\n    formData.raw = raw;\n  }\n\n  //    console.log( `account_history request ${JSON.stringify( formData )}` );\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      // console.log( `account_history response ${JSON.stringify( json )}` );\n      resolve(json);\n    });\n  });\n};\n\nconst getAccountInfo = async (account, representativeFlag) => {\n  if (account === undefined) {\n    throw Error(`'account' is a required parameter.`);\n  }\n  // https://docs.nano.org/commands/rpc-protocol/#account_info\n  const formData = {\n    action: 'account_info',\n    account: account,\n  };\n\n  if (representativeFlag !== undefined) {\n    if (representativeFlag) {\n      formData.representative = 'true';\n    } else {\n      formData.representative = 'false';\n    }\n  }\n\n  //    console.log( `account_history request ${JSON.stringify( formData )}` );\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      // console.log( `account_history response ${JSON.stringify( json )}` );\n      resolve(json);\n    });\n  });\n};\n\nconst getBlocks = async (hashes, source) => {\n  if (hashes === undefined) {\n    throw Error(`'hashes' is a required parameter.`);\n  }\n  // https://github.com/nanocurrency/nano-node/wiki/RPC-protocol#retrieve-multiple-blocks\n  const formData = {\n    action: 'blocks',\n    hashes: hashes,\n  };\n\n  if (source !== undefined) {\n    formData.source = source;\n  }\n\n  //    console.log( `account_history request ${JSON.stringify( formData )}` );\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      // console.log( `account_history response ${JSON.stringify( json )}` );\n      resolve(json);\n    });\n  });\n};\n\nconst process = async (block) => {\n  if (block == undefined) {\n    throw Error(`'block' is a required parameter.'`);\n  }\n\n  // https://docs.nano.org/commands/rpc-protocol#process-block\n  const formData = {\n    action: 'process',\n    block: JSON.stringify(block),\n  };\n  if (block.work === undefined) {\n    formData.do_work = true;\n  }\n  //    console.log( `process request ${JSON.stringify( formData )}` );\n  return new Promise((resolve, reject) => {\n    sendRequest(formData).then((json) => {\n      //            console.log( `process response ${JSON.stringify( json )}` );\n      if (json === undefined) {\n        resolve('');\n      } else {\n        if (json.hash === undefined) {\n          console.log(`process reject ${JSON.stringify( json )}`);\n          reject(json);\n        } else {\n          const hash = json.hash;\n          resolve(hash);\n        }\n      }\n    });\n  });\n};\n\nconst getGeneratedWork = async (hash) => {\n  // https://docs.nano.org/commands/rpc-protocol#work-generate\n  const formData = {\n    action: 'work_generate',\n    hash: hash,\n  };\n\n  if (LOG_GET_GENERATED_WORK) {\n    console.log(`STARTED getGeneratedWork request ${JSON.stringify( formData )}`);\n  }\n\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      if (json === undefined) {\n        resolve('');\n      } else {\n        if (LOG_GET_GENERATED_WORK) {\n          console.log(`SUCCESS getGeneratedWork response ${JSON.stringify( json )}`);\n        }\n        const work = json.work;\n        resolve(work);\n      }\n    });\n  });\n};\n\nconst getAccountsPending = async (accounts, count, source) => {\n  if (accounts === undefined) {\n    throw Error('accounts is a required parameter.');\n  }\n  if (count === undefined) {\n    throw Error('count is a required parameter.');\n  }\n  // https://docs.nano.org/commands/rpc-protocol/#accounts_pending\n  const formData = {\n    action: 'accounts_pending',\n    accounts: accounts,\n    count: count,\n    threshold: 1,\n  };\n\n  if (source !== undefined) {\n    if (source) {\n      formData.source = 'true';\n    } else {\n      formData.source = 'false';\n    }\n  }\n  //    console.log( `accounts_pending request ${JSON.stringify( formData )}` );\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      //            console.log( `accounts_pending response ${JSON.stringify( json )}` );\n      resolve(json);\n    });\n  });\n};\n\nconst getBlockAccount = async (hash) => {\n  if (hash === undefined) {\n    throw Error('hash is a required parameter.');\n  }\n  // https://github.com/nanocurrency/nano-node/wiki/RPC-protocol#block-account\n  const formData = {\n    action: 'block_account',\n    hash: hash,\n  };\n  //    console.log( `block_account request ${JSON.stringify( formData )}` );\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      //            console.log( `block_account response ${JSON.stringify( json )}` );\n      resolve(json);\n    });\n  });\n};\n\nconst getFrontiers = async (account, count) => {\n  if (account === undefined) {\n    throw Error('account is a required parameter.');\n  }\n  if (count === undefined) {\n    throw Error('count is a required parameter.');\n  }\n  // https://github.com/nanocurrency/nano-node/wiki/RPC-protocol#frontiers\n  const formData = {\n    action: 'frontiers',\n    account: account,\n    count: count,\n  };\n  //    console.log( `frontiers request ${JSON.stringify( formData )}` );\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      //            console.log( `frontiers response ${JSON.stringify( json )}` );\n      resolve(json);\n    });\n  });\n};\n\nconst getBlockCount = async () => {\n  // https://docs.nano.org/commands/rpc-protocol/#block_count\n  const formData = {\n    action: 'block_count',\n  };\n  //    console.log( `block_count request ${JSON.stringify( formData )}` );\n  return new Promise((resolve) => {\n    sendRequest(formData).then((json) => {\n      //            console.log( `block_count response ${JSON.stringify( json )}` );\n      resolve(json);\n    });\n  });\n};\n\nconst setUrl = (newUrl) => {\n  url = newUrl;\n};\n\nexports.setUrl = setUrl;\nexports.getFrontiers = getFrontiers;\nexports.getBlockAccount = getBlockAccount;\nexports.getAccountsPending = getAccountsPending;\nexports.getAccountBalanceRaw = getAccountBalanceRaw;\nexports.getAccountRepresentative = getAccountRepresentative;\nexports.getPrevious = getPrevious;\nexports.process = process;\nexports.getGeneratedWork = getGeneratedWork;\nexports.getAccountHistory = getAccountHistory;\nexports.getAccountInfo = getAccountInfo;\nexports.getBlocks = getBlocks;\nexports.getBlockCount = getBlockCount;\nexports.log = console.log;\nexports.trace = console.trace;\n\n\n//# sourceURL=webpack:///./app/scripts/bananode-api.js?");

/***/ }),

/***/ "./app/scripts/camo-util.js":
/*!**********************************!*\
  !*** ./app/scripts/camo-util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst nacl = __webpack_require__( /*! ../../libraries/tweetnacl/nacl.js */ \"./libraries/tweetnacl/nacl.js\" );\n\nconst bananoUtil = __webpack_require__( /*! ./banano-util.js */ \"./app/scripts/banano-util.js\" );\n\nconst blake = __webpack_require__( /*! blakejs */ \"./node_modules/blakejs/index.js\" );\n\nconst camoAmountRaw = 1;\n\nconst LOG_SWEEP_SEED_TO_INDEX = false;\n\nconst LOG_IS_HASH_IN_PENDING_OF_PRIVATE_KEY = false;\n\nconst LOG_SPLIT_BIG_INT_INTO_POWERS_OF_TWO = false;\n\nconst LOG_SEND = false;\n\nconst LOG_RECEIVE = false;\n\n/**\n * Gets the camo public key from a private key.\n *\n * a normal banano public key is used in ECDSA.\n *\n * a camo public key is used in ECDH.\n *\n * this is why the derivation is different for the two keys.\n *\n * @memberof CamoUtil\n * @param {string} privateKey the private key.\n * @return {string} the camo public key.\n */\nconst getCamoPublicKey = ( privateKey ) => {\n  const privateKeyBytes = bananoUtil.hexToBytes( privateKey );\n  const camoPublicKeyBytes = getCamoPublicKeyBytes( privateKeyBytes );\n  const camoPublicKey = bananoUtil.bytesToHex( camoPublicKeyBytes );\n  return camoPublicKey;\n};\n\nconst getCamoPublicKeyBytes = ( privateKeyBytes ) => {\n  const camoPrivateKeyBytes = nacl.camo.hashsecret( privateKeyBytes );\n  const camoPublicKeyBytes = nacl.camo.scalarMult.base( camoPrivateKeyBytes );\n  return camoPublicKeyBytes;\n};\n\nconst getSharedSecretBytes = ( privateKeyBytes, publicKeyBytes ) => {\n  const camoPrivateKeyBytes = nacl.camo.hashsecret( privateKeyBytes );\n  const secretBytes = nacl.camo.scalarMult( camoPrivateKeyBytes, publicKeyBytes );\n\n  const context = blake.blake2bInit( 32 );\n  blake.blake2bUpdate( context, secretBytes );\n  const hashedSecretBytes = blake.blake2bFinal( context );\n\n  return hashedSecretBytes;\n};\n\n\n/**\n * Gets the shared secret from a camo public key and a private key.\n *\n * @memberof CamoUtil\n * @param {string} privateKey the private key.\n * @param {string} publicKey the public key.\n * @return {string} the shared secret.\n */\nconst getSharedSecret = ( privateKey, publicKey ) => {\n  const privateKeyBytes = bananoUtil.hexToBytes( privateKey );\n  const publicKeyBytes = bananoUtil.hexToBytes( publicKey );\n  const secretBytes = getSharedSecretBytes( privateKeyBytes, publicKeyBytes );\n  const secret = bananoUtil.bytesToHex( secretBytes );\n  return secret;\n};\n\n// const getSharedSeed = ( privateKey, publicKey, ix ) => {\n//   const secret = getSharedSecret( privateKey, publicKey );\n//   return bananoUtil.getPrivateKey( secret, ix );\n// };\n\nconst isUnopenedPrivateKeyInSeed = async ( bananodeApi, seed, seedIx ) => {\n  const privateKey = bananoUtil.getPrivateKey( seed, seedIx );\n  return await isUnopenedPrivateKey( bananodeApi, privateKey );\n};\n\nconst isUnopenedPrivateKey = async ( bananodeApi, privateKey ) => {\n  const publicKey = bananoUtil.getPublicKey( privateKey );\n  const account = bananoUtil.getAccount( publicKey );\n  // console.log( 'account', account );\n  const history = await bananodeApi.getAccountHistory( account, 1 );\n  // console.log( 'history', JSON.stringify( history, undefined, '  ' ) );\n  const history_history = history.history;\n  // console.log( 'history_history', JSON.stringify( history_history, undefined, '  ' ) );\n  const history_history_length = history_history.length;\n  // console.log( 'history_history_length', history_history_length );\n  const history_history_length_is_0 = history_history_length == 0;\n\n  // console.log( 'isUnopenedPrivateKey', account, history_history_length_is_0 );\n\n  return history_history_length_is_0;\n};\n\nconst getFirstUnopenedPrivateKey = async ( bananodeApi, seed ) => {\n  /* istanbul ignore if */\n  if ( bananodeApi === undefined ) {\n    throw Error( 'bananodeApi is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( seed === undefined ) {\n    throw Error( 'seed is a required parameter.' );\n  }\n  let seedIx = 0;\n  let isUnopenedPrivateKeyFlag = await isUnopenedPrivateKeyInSeed( bananodeApi, seed, seedIx );\n  while ( !isUnopenedPrivateKeyFlag ) {\n    seedIx++;\n    isUnopenedPrivateKeyFlag = await isUnopenedPrivateKeyInSeed( bananodeApi, seed, seedIx );\n  }\n  //    console.log( 'getFirstUnopenedPrivateKey', seed, seedIx );\n  return bananoUtil.getPrivateKey( seed, seedIx );\n};\n\n// const openAccountWithPrivateKey = async ( bananodeApi, fundingSourcePrivateKey, destPrivateKey ) => {\n//   /* istanbul ignore if */\n//   if ( bananodeApi === undefined ) {\n//     throw Error( 'bananodeApi is a required parameter.' );\n//   }\n//   /* istanbul ignore if */\n//   if ( fundingSourcePrivateKey === undefined ) {\n//     throw Error( 'fundingSourcePrivateKey is a required parameter.' );\n//   }\n//   /* istanbul ignore if */\n//   if ( destPrivateKey === undefined ) {\n//     throw Error( 'destPrivateKey is a required parameter.' );\n//   }\n//   if ( await isUnopenedPrivateKey( bananodeApi, fundingSourcePrivateKey ) ) {\n//     throw Error( 'fundingSourcePrivateKey is not an open account.' );\n//   }\n//   if ( ! await isUnopenedPrivateKey( bananodeApi, destPrivateKey ) ) {\n//     throw Error( 'destPrivateKey is not an open account.' );\n//   }\n//   const destPublicKey = bananoUtil.getPublicKey( destPrivateKey );\n//   const destAccount = bananoUtil.getAccount( destPublicKey );\n//\n//   //    console.log( 'sendFromPrivateKey destAccount', destAccount );\n//\n//   const accountsPending = await bananodeApi.getAccountsPending( [destAccount], 1 );\n//\n//   const pendingBlocks = Object.keys( accountsPending.blocks[destAccount] );\n//\n//   if ( pendingBlocks.length > 0 ) {\n//     const existingHash = pendingBlocks[0];\n//     // console.log( `sendFromPrivateKey returned existingHash ${destAccount} ${existingHash}` );\n//     return existingHash;\n//   }\n//\n//   const camoPublicKey = getCamoPublicKey( destPrivateKey );\n//   const camoAccount = bananoUtil.getAccount( camoPublicKey );\n//\n//   //    console.log( 'destPrivateKey', destPrivateKey );\n//   //    console.log( 'camoAccount', camoAccount );\n//\n//   const sendHash = await bananoUtil.sendFromPrivateKeyWithRepresentative( bananodeApi, fundingSourcePrivateKey, destAccount, camoAmountRaw, camoAccount );\n//   if ( sendHash == undefined ) {\n//     throw Error( 'sendFromPrivateKey failed, undefined has returned from RPC process-block.' );\n//   } else {\n//     //        console.log( `sendFromPrivateKey returned sendHash ${destAccount} ${sendHash}` );\n//     return sendHash;\n//   }\n// };\n\n// const sweepSeedToIndex = async ( bananodeApi, seed, destPrivateKey ) => {\n//   /* istanbul ignore if */\n//   if ( bananodeApi === undefined ) {\n//     throw Error( 'bananodeApi is a required parameter.' );\n//   }\n//   /* istanbul ignore if */\n//   if ( seed === undefined ) {\n//     throw Error( 'seed is a required parameter.' );\n//   }\n//   /* istanbul ignore if */\n//   if ( destPrivateKey === undefined ) {\n//     throw Error( 'destPrivateKey is a required parameter.' );\n//   }\n//   // TODO : send to destPrivateKey, rather than just receiveSeed.\n//   return receiveSeed( bananodeApi, seed );\n// };\n\nconst receiveSeed = async ( bananodeApi, seed ) => {\n  /* istanbul ignore if */\n  if ( bananodeApi === undefined ) {\n    throw Error( 'bananodeApi is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( seed === undefined ) {\n    throw Error( 'seed is a required parameter.' );\n  }\n  const unopenedAccounts = [];\n  const privateKeyByAccount = {};\n  const publicKeyByAccount = {};\n  const representativeByAccount = {};\n\n  const getAccount = ( seed, seedIx ) => {\n    const privateKey = bananoUtil.getPrivateKey( seed, seedIx );\n    const publicKey = bananoUtil.getPublicKey( privateKey );\n    const account = bananoUtil.getAccount( publicKey );\n    const camoPublicKey = getCamoPublicKey( privateKey );\n    const camoAccount = bananoUtil.getAccount( camoPublicKey );\n\n    privateKeyByAccount[account] = privateKey;\n    publicKeyByAccount[account] = publicKey;\n    representativeByAccount[account] = camoAccount;\n\n    return account;\n  };\n\n  let seedIx = 0;\n  let isUnopenedPrivateKeyFlag = await isUnopenedPrivateKeyInSeed( bananodeApi, seed, seedIx );\n  unopenedAccounts.push( getAccount( seed, seedIx ) );\n  while ( !isUnopenedPrivateKeyFlag ) {\n    /* istanbul ignore if */\n    if (LOG_RECEIVE) {\n      console.log( 'INTERIM camo.receiveSeed', 'unopenedAccounts', 'seedIx', seedIx );\n    }\n\n    seedIx++;\n    unopenedAccounts.push( getAccount( seed, seedIx ) );\n    isUnopenedPrivateKeyFlag = await isUnopenedPrivateKeyInSeed( bananodeApi, seed, seedIx );\n  }\n  /* istanbul ignore if */\n  if (LOG_RECEIVE) {\n    console.log( 'accountsPending request', unopenedAccounts);\n  }\n  const accountsPending = await bananodeApi.getAccountsPending( unopenedAccounts, -1 );\n  /* istanbul ignore if */\n  if (LOG_RECEIVE) {\n    console.log( 'accountsPending response', accountsPending );\n  }\n\n\n  const accounts = Object.keys( accountsPending.blocks );\n\n  const accountOpenAndReceiveBlocks = [];\n\n  for ( let accountIx = 0; accountIx < accounts.length; accountIx++ ) {\n    const account = accounts[accountIx];\n    const privateKey = privateKeyByAccount[account];\n    const publicKey = publicKeyByAccount[account];\n    const representative = representativeByAccount[account];\n    let isAccountOpenFlag = await bananoUtil.isAccountOpen(bananodeApi, account);\n    const pendingBlockHashs = Object.keys( accountsPending.blocks[account] );\n    for ( let pendingBlockHashIx = 0; pendingBlockHashIx < pendingBlockHashs.length; pendingBlockHashIx++ ) {\n      const pendingBlockHash = pendingBlockHashs[pendingBlockHashIx];\n      const pendingValueRaw = accountsPending.blocks[account][pendingBlockHash];\n      if ( pendingBlockHashIx !== 0 ) {\n        isAccountOpenFlag = false;\n      }\n\n      const blockHash = await receiveBlock(bananodeApi, isAccountOpenFlag, account, privateKey, publicKey, representative, pendingBlockHash, pendingValueRaw);\n\n      accountOpenAndReceiveBlocks.push( blockHash );\n    }\n  }\n\n  return accountOpenAndReceiveBlocks;\n};\n\nconst receiveBlock = async (bananodeApi, isAccountOpenFlag, account, privateKey, publicKey, representative, pendingBlockHash, pendingValueRaw) => {\n  /* istanbul ignore if */\n  if ( bananodeApi === undefined ) {\n    throw Error( 'bananodeApi is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( isAccountOpenFlag === undefined ) {\n    throw Error( 'isAccountOpenFlag is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( account === undefined ) {\n    throw Error( 'account is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( privateKey === undefined ) {\n    throw Error( 'privateKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( publicKey === undefined ) {\n    throw Error( 'publicKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( representative === undefined ) {\n    throw Error( 'representative is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( pendingBlockHash === undefined ) {\n    throw Error( 'pendingBlockHash is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( pendingValueRaw === undefined ) {\n    throw Error( 'pendingValueRaw is a required parameter.' );\n  }\n  const frontiers = await bananodeApi.getFrontiers( account, 1 );\n  if (isAccountOpenFlag) {\n    const previous = frontiers.frontiers[account];\n    const hash = pendingBlockHash;\n    const valueRaw = pendingValueRaw;\n    const receiveBlockHash = await bananoUtil.receive( bananodeApi, privateKey, publicKey, representative, previous, hash, valueRaw );\n\n    /* istanbul ignore if */\n    if ( LOG_SWEEP_SEED_TO_INDEX ) {\n      console.log( `accountsPending receiveBlockHash[${accountIx}]`, account, receiveBlockHash );\n    }\n    return receiveBlockHash;\n  } else {\n    const pending = pendingBlockHash;\n    const openBlockHash = await bananoUtil.open( bananodeApi, privateKey, publicKey, representative, pending, pendingValueRaw );\n\n    /* istanbul ignore if */\n    if ( LOG_SWEEP_SEED_TO_INDEX ) {\n      console.log( `accountsPending openBlockHash[${accountIx}]`, account, openBlockHash );\n    }\n    return openBlockHash;\n  }\n};\n\n// const isHashInPendingOfPrivateKey = async ( bananodeApi, privateKey, blockHash ) => {\n//   /* istanbul ignore if */\n//   if ( bananodeApi === undefined ) {\n//     throw Error( 'bananodeApi is a required parameter.' );\n//   }\n//   /* istanbul ignore if */\n//   if ( privateKey === undefined ) {\n//     throw Error( 'privateKey is a required parameter.' );\n//   }\n//   /* istanbul ignore if */\n//   if ( blockHash === undefined ) {\n//     throw Error( 'blockHash is a required parameter.' );\n//   }\n//\n//   const publicKey = bananoUtil.getPublicKey( privateKey );\n//   const account = bananoUtil.getAccount( publicKey );\n//\n//   const accountsPending = await bananodeApi.getAccountsPending( [account], -1 );\n//\n//   const history = await bananodeApi.getAccountHistory( account, 1 );\n//   const history_history = history.history;\n//   const history_history_length = history_history.length;\n//\n//   /* istanbul ignore if */\n//   if ( LOG_IS_HASH_IN_PENDING_OF_PRIVATE_KEY ) {\n//     console.log( `isHashInPendingOfPrivateKey`,\n//         'account', account,\n//         'blockHash', blockHash,\n//         'history_history', history_history,\n//         'accountsPending.blocks[account]', accountsPending.blocks[account] );\n//   }\n//\n//   const missHashes = [];\n//\n//   for ( let historyIx = 0; historyIx < history_history.length; historyIx++ ) {\n//     const historyBlock = history_history[historyIx];\n//     const historyBlockHash = historyBlock.hash;\n//     if ( blockHash == historyBlockHash ) {\n//       return true;\n//     } else {\n//       missHashes.push( historyBlockHash );\n//     }\n//   }\n//\n//   const pendingBlockHashs = Object.keys( accountsPending.blocks[account] );\n//   for ( let pendingBlockHashIx = 0; pendingBlockHashIx < pendingBlockHashs.length; pendingBlockHashIx++ ) {\n//     const pendingBlockHash = pendingBlockHashs[pendingBlockHashIx];\n//     if ( blockHash == pendingBlockHash ) {\n//       return true;\n//     } else {\n//       missHashes.push( pendingBlockHash );\n//     }\n//   }\n//\n//   /* istanbul ignore if */\n//   if ( LOG_IS_HASH_IN_PENDING_OF_PRIVATE_KEY ) {\n//     console.log( `isHashInPendingOfPrivateKey false`, 'account', account, 'blockHash', blockHash, 'missHashes', missHashes );\n//   }\n//\n//   return false;\n// };\n\nconst getSharedSecretFromRepresentative = async ( bananodeApi, toPrivateKey, fromPublicKey ) => {\n  /* istanbul ignore if */\n  if ( bananodeApi === undefined ) {\n    throw Error( 'bananodeApi is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( toPrivateKey === undefined ) {\n    throw Error( 'toPrivateKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( fromPublicKey === undefined ) {\n    throw Error( 'fromPublicKey is a required parameter.' );\n  }\n  const fromAccount = bananoUtil.getAccount( fromPublicKey );\n  const fromRepresentative = await bananodeApi.getAccountRepresentative( fromAccount );\n  if (fromRepresentative) {\n    const fromCamoPublicKey = bananoUtil.getAccountPublicKey( fromRepresentative );\n    const sharedSecret = getSharedSecret( toPrivateKey, fromCamoPublicKey );\n    return sharedSecret;\n  } else {\n    return undefined;\n  }\n};\n\nconst getBalanceRaw = async ( bananodeApi, toPrivateKey, fromPublicKey ) => {\n  const sharedSecret = await getSharedSecretFromRepresentative( bananodeApi, toPrivateKey, fromPublicKey );\n\n  const seed = sharedSecret;\n\n  const ZERO = BigInt( 0 );\n\n  let balanceRaw = ZERO;\n\n  let seedIx = 0;\n  let accountHasBalance = true;\n  while ( accountHasBalance ) {\n    const privateKey = bananoUtil.getPrivateKey( seed, seedIx );\n    const publicKey = bananoUtil.getPublicKey( privateKey );\n    const account = bananoUtil.getAccount( publicKey );\n    const accountBalanceRaw = await bananodeApi.getAccountBalanceRaw( account );\n\n    const accountBalanceRawBigInt = BigInt( accountBalanceRaw );\n    // console.log( 'getBalanceRaw', account, accountBalanceRawBigInt);\n\n    if ( accountBalanceRawBigInt == ZERO ) {\n      accountHasBalance = false;\n    } else {\n      balanceRaw += accountBalanceRawBigInt;\n      seedIx++;\n    }\n  }\n\n  return balanceRaw.toString();\n};\n\n// def myfunc(x):\n//    powers = []\n//    i = 1\n//    while i <= x:\n//        if i & x:\n//            powers.append(i)\n//        i <<= 1\n//    return powers\n\nconst splitBigIntIntoPowersOfTwo = ( value ) => {\n  const ZERO = BigInt( 0 );\n  const ONE = BigInt( 1 );\n\n  /* istanbul ignore if */\n  if ( LOG_SPLIT_BIG_INT_INTO_POWERS_OF_TWO ) {\n    console.log( 'STARTED splitBigIntIntoPowersOfTwo', 'value', value );\n  }\n\n  const powersOfTwo = [];\n\n  let divisor = ONE;\n\n  /* istanbul ignore if */\n  if ( LOG_SPLIT_BIG_INT_INTO_POWERS_OF_TWO ) {\n    console.log( `INTERIM splitBigIntIntoPowersOfTwo`,\n        'value', value, 'divisor', divisor );\n  }\n  while ( divisor <= value ) {\n    /* istanbul ignore if */\n    if ( LOG_SPLIT_BIG_INT_INTO_POWERS_OF_TWO ) {\n      console.log( `INTERIM splitBigIntIntoPowersOfTwo`,\n          'while ( divisor <= value )',\n          'value', value, 'divisor', divisor );\n    }\n    if ( divisor & value ) {\n      /* istanbul ignore if */\n      if ( LOG_SPLIT_BIG_INT_INTO_POWERS_OF_TWO ) {\n        console.log( `INTERIM splitBigIntIntoPowersOfTwo`,\n            '(divisor & value)=true',\n            'value', value, 'divisor', divisor );\n      }\n      powersOfTwo.push( divisor );\n    } else {\n      /* istanbul ignore if */\n      if ( LOG_SPLIT_BIG_INT_INTO_POWERS_OF_TWO ) {\n        console.log( `INTERIM splitBigIntIntoPowersOfTwo`,\n            '(divisor & value)=false',\n            'value', value, 'divisor', divisor );\n      }\n    }\n\n    divisor <<= ONE;\n\n    /* istanbul ignore if */\n    if ( LOG_SPLIT_BIG_INT_INTO_POWERS_OF_TWO ) {\n      console.log( `INTERIM splitBigIntIntoPowersOfTwo`, value, divisor );\n    }\n  }\n\n  /* istanbul ignore if */\n  if ( LOG_SPLIT_BIG_INT_INTO_POWERS_OF_TWO ) {\n    console.log( 'SUCCESS splitBigIntIntoPowersOfTwo', value, powersOfTwo );\n  }\n\n  return powersOfTwo;\n};\n\nconst send = async ( bananodeApi, fundingPrivateKey, fromPrivateKey, toPublicKey, amountRaw ) => {\n  /* istanbul ignore if */\n  if ( bananodeApi === undefined ) {\n    throw Error( 'bananodeApi is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( fundingPrivateKey === undefined ) {\n    throw Error( 'fundingPrivateKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( fromPrivateKey === undefined ) {\n    throw Error( 'fromPrivateKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( toPublicKey === undefined ) {\n    throw Error( 'toPublicKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( amountRaw === undefined ) {\n    throw Error( 'amountRaw is a required parameter.' );\n  }\n\n  /* istanbul ignore if */\n  if ( LOG_SEND ) {\n    console.log( 'camo.send.amountRaw', amountRaw );\n  }\n\n  const bananoParts = bananoUtil.getBananoPartsFromRaw( amountRaw );\n\n  /* istanbul ignore if */\n  if ( LOG_SEND ) {\n    console.log( 'camo.send.bananoParts', bananoParts );\n  }\n\n  const powersOfTwoBigInts = splitBigIntIntoPowersOfTwo( BigInt( bananoParts.banano ) );\n\n  /* istanbul ignore if */\n  if ( LOG_SEND ) {\n    console.log( 'camo.send.powersOfTwoBigInts', powersOfTwoBigInts );\n  }\n\n  const amounts = [];\n\n  if ( bananoParts.banoshi !== '0' ) {\n    /* istanbul ignore if */\n    if ( LOG_SEND ) {\n      console.log( 'camo.send.bananoParts.banoshi', bananoParts.banoshi );\n    }\n    const banoshiRaw = bananoUtil.getRawStrFromBanoshiStr( bananoParts.banoshi );\n    /* istanbul ignore if */\n    if ( LOG_SEND ) {\n      console.log( 'camo.send.banoshiRaw', banoshiRaw );\n    }\n    amounts.push( banoshiRaw );\n  }\n  if ( bananoParts.raw !== '0' ) {\n    /* istanbul ignore if */\n    if ( LOG_SEND ) {\n      console.log( 'camo.send.raw', bananoParts.raw );\n    }\n    amounts.push( bananoParts.raw );\n  }\n\n  for ( let powersOfTwoBigIntIx = 0; powersOfTwoBigIntIx < powersOfTwoBigInts.length; powersOfTwoBigIntIx++ ) {\n    const powersOfTwoBigInt = powersOfTwoBigInts[powersOfTwoBigIntIx];\n    const powersOfTwoRaw = bananoUtil.getRawStrFromBananoStr( powersOfTwoBigInt.toString() );\n    /* istanbul ignore if */\n    if ( LOG_SEND ) {\n      console.log( `camo.send.powersOfTwoRaw[${powersOfTwoBigIntIx}]`, powersOfTwoRaw );\n    }\n    amounts.push( powersOfTwoRaw );\n  }\n\n  const sharedSecret = await getSharedSecretFromRepresentative( bananodeApi, fromPrivateKey, toPublicKey );\n  /* istanbul ignore if */\n  if ( LOG_SEND ) {\n    console.log( 'camo.send.sharedSecret', sharedSecret );\n  }\n\n  const destSeed = sharedSecret;\n\n  const hashes = [];\n\n  let previous;\n\n  for ( let amountIx = 0; amountIx < amounts.length; amountIx++ ) {\n    const amount = amounts[amountIx];\n    const amountRaw = amount;\n    const destSeedIx = amountIx;\n    const destPrivateKey = bananoUtil.getPrivateKey( destSeed, destSeedIx );\n    const destPublicKey = bananoUtil.getPublicKey( destPrivateKey );\n    const destAccount = bananoUtil.getAccount( destPublicKey );\n    /* istanbul ignore if */\n    if ( LOG_SEND ) {\n      console.log( `STARTED camo.send[${destSeedIx}]`, fundingPrivateKey, destAccount, amountRaw );\n    }\n    const hash = await bananoUtil.sendFromPrivateKeyWithRepresentativeAndPrevious( bananodeApi, fundingPrivateKey, destAccount, amountRaw, undefined, previous );\n    /* istanbul ignore if */\n    if ( LOG_SEND ) {\n      console.log( `SUCCESS camo.send[${destSeedIx}]`, 'destPrivateKey', destPrivateKey, 'hash', hash );\n    }\n    previous = hash;\n    hashes.push( hash );\n  }\n\n  return hashes;\n};\n\nconst receive = async ( bananodeApi, toPrivateKey, fromPublicKey ) => {\n  /* istanbul ignore if */\n  if ( bananodeApi === undefined ) {\n    throw Error( 'bananodeApi is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( toPrivateKey === undefined ) {\n    throw Error( 'toPrivateKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( fromPublicKey === undefined ) {\n    throw Error( 'fromPublicKey is a required parameter.' );\n  }\n\n  /* istanbul ignore if */\n  if (LOG_RECEIVE) {\n    console.log( 'STARTED camo.receive', toPrivateKey, fromPublicKey );\n  }\n\n  const sharedSecret = await getSharedSecretFromRepresentative( bananodeApi, toPrivateKey, fromPublicKey );\n  /* istanbul ignore if */\n  if (LOG_RECEIVE) {\n    console.log( 'INTERIM camo.receive', 'sharedSecret', sharedSecret );\n  }\n  const seed = sharedSecret;\n\n  const returnValue = await receiveSeed( bananodeApi, seed );\n  /* istanbul ignore if */\n  if (LOG_RECEIVE) {\n    console.log( 'SUCCESS camo.receive', returnValue );\n  }\n  return returnValue;\n};\n\n\n/**\n * Get the camo account for a given camo public key.\n *\n * @memberof CamoUtil\n * @param {string} publicKey the camo public key.\n * @return {string} the camo account.\n */\nconst getCamoAccount = (camoPublicKey) => {\n  const accountSuffix = bananoUtil.getAccountSuffix(camoPublicKey);\n  return `camo_${accountSuffix}`;\n};\n\n/**\n* @memberof CamoUtil\n * checks if a camo account is valid.\n * @param {string} publicKey the camo public key.\n * @return {boolean} true if the camo account is valid.\n */\nconst isCamoAccountValid = (camoAccount) => {\n  if (((!camoAccount.startsWith('camo_1')) &&\n        (!camoAccount.startsWith('camo_3')))) {\n    const retval = {};\n    retval.valid = false;\n    retval.message = `Invalid CAMO BANANO Account prefix '${camoAccount}'`;\n    return retval;\n  }\n  if (camoAccount.length !== 65) {\n    const retval = {};\n    retval.valid = false;\n    retval.message = `Invalid CAMO BANANO Account length ${camoAccount.length} of '${camoAccount}'`;\n    return retval;\n  }\n  const accountSuffix = camoAccount.substring(5, 65);\n  const isSuffixValid = bananoUtil.isAccountSuffixValid(accountSuffix);\n  if (!isSuffixValid.valid) {\n    const retval = {};\n    retval.valid = false;\n    retval.message = `Invalid CAMO BANANO Account '${camoAccount}', ${isSuffixValid.message}`;\n    return retval;\n  }\n  const retval = {};\n  retval.valid = true;\n  retval.message = '';\n  return retval;\n};\n\nconst getSharedAccountData = async (bananodeApi, privateKey, publicKey, sharedSeedIx) => {\n  /* istanbul ignore if */\n  if ( bananodeApi === undefined ) {\n    throw Error( 'bananodeApi is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( privateKey === undefined ) {\n    throw Error( 'privateKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( publicKey === undefined ) {\n    throw Error( 'publicKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( sharedSeedIx === undefined ) {\n    throw Error( 'sharedSeedIx is a required parameter.' );\n  }\n  const sharedSecret = await getSharedSecretFromRepresentative( bananodeApi, privateKey, publicKey );\n  if (sharedSecret) {\n    const sharedSeed = sharedSecret;\n    const sharedPrivateKey = bananoUtil.getPrivateKey( sharedSeed, sharedSeedIx );\n    const sharedPublicKey = bananoUtil.getPublicKey( sharedPrivateKey );\n    const sharedAccount = bananoUtil.getAccount( sharedPublicKey );\n    const data = {};\n    data.sharedSeed = sharedSeed;\n    data.sharedPrivateKey = sharedPrivateKey;\n    data.sharedPublicKey = sharedPublicKey;\n    data.sharedAccount = sharedAccount;\n    return data;\n  } else {\n    return undefined;\n  }\n};\n\nconst getAccountsPending = async (bananodeApi, toPrivateKey, fromPublicKey, sharedSeedIx, count) => {\n  /* istanbul ignore if */\n  if ( bananodeApi === undefined ) {\n    throw Error( 'bananodeApi is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( toPrivateKey === undefined ) {\n    throw Error( 'toPrivateKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( fromPublicKey === undefined ) {\n    throw Error( 'fromPublicKey is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( sharedSeedIx === undefined ) {\n    throw Error( 'sharedSeedIx is a required parameter.' );\n  }\n  /* istanbul ignore if */\n  if ( count === undefined ) {\n    throw Error( 'count is a required parameter.' );\n  }\n  const accountData = await getSharedAccountData(bananodeApi, toPrivateKey, fromPublicKey, sharedSeedIx);\n  if (accountData) {\n    const accounts = [accountData.sharedAccount];\n    return bananodeApi.getAccountsPending(accounts, count);\n  }\n};\n\nexports.receiveSeed = receiveSeed;\nexports.receive = receive;\nexports.send = send;\nexports.getBalanceRaw = getBalanceRaw;\n// exports.isHashInPendingOfPrivateKey = isHashInPendingOfPrivateKey;\n// exports.sweepSeedToIndex = sweepSeedToIndex;\nexports.getSharedSecret = getSharedSecret;\nexports.getSharedSecretBytes = getSharedSecretBytes;\nexports.getCamoPublicKey = getCamoPublicKey;\nexports.getCamoPublicKeyBytes = getCamoPublicKeyBytes;\n// exports.getSharedSeed = getSharedSeed;\nexports.getFirstUnopenedPrivateKey = getFirstUnopenedPrivateKey;\n// exports.openAccountWithPrivateKey = openAccountWithPrivateKey;\nexports.getCamoAccount = getCamoAccount;\nexports.isCamoAccountValid = isCamoAccountValid;\nexports.getAccountsPending = getAccountsPending;\nexports.getSharedAccountData = getSharedAccountData;\nexports.receiveBlock = receiveBlock;\nexports.getSharedSecretFromRepresentative = getSharedSecretFromRepresentative;\n\n\n//# sourceURL=webpack:///./app/scripts/camo-util.js?");

/***/ }),

/***/ "./app/scripts/deposit-util.js":
/*!*************************************!*\
  !*** ./app/scripts/deposit-util.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst bananoUtil = __webpack_require__(/*! ./banano-util.js */ \"./app/scripts/banano-util.js\");\n\nconst MAX_ACCOUNTS_PENDING = 10;\n\nconst LOG_SWEEP = false;\n\nconst receive = async (loggingUtil, bananodeApi, account, privateKey, representative, specificPendingBlockHash) => {\n  /* istanbul ignore if */\n  if (loggingUtil === undefined) {\n    throw Error('loggingUtil is required.');\n  }\n  /* istanbul ignore if */\n  if (bananodeApi === undefined) {\n    throw Error('bananodeApi is required.');\n  }\n  /* istanbul ignore if */\n  if (account === undefined) {\n    throw Error('account is required.');\n  }\n  /* istanbul ignore if */\n  if (privateKey === undefined) {\n    throw Error('privateKey is required.');\n  }\n  /* istanbul ignore if */\n  if (representative === undefined) {\n    throw Error('representative is required.');\n  }\n  /* istanbul ignore if */\n  if (LOG_SWEEP) {\n    loggingUtil.log('STARTED receive account', account);\n  }\n  const pending = await bananodeApi.getAccountsPending([account], MAX_ACCOUNTS_PENDING);\n  const response = {};\n  response.pendingCount = 0;\n  response.pendingBlocks = [];\n  response.receiveCount = 0;\n  response.receiveBlocks = [];\n  response.pendingMessage = '';\n  response.receiveMessage = '';\n  if ((pending !== undefined) && (pending.blocks !== undefined) && (pending.blocks[account] !== undefined)) {\n    const pendingHashes = Object.keys(pending.blocks[account]);\n    response.pendingMessage = `pending ${pendingHashes.length} blocks, of max ${MAX_ACCOUNTS_PENDING}.`;\n    response.pendingCount = pendingHashes.length;\n    response.pendingBlocks = pendingHashes;\n    /* istanbul ignore if */\n    if (LOG_SWEEP) {\n      loggingUtil.log('INTERIM receive pendingHashes', pendingHashes);\n    }\n    if (pendingHashes.length > 0) {\n      const sweepBlocks = await sweep(loggingUtil, bananodeApi, privateKey, representative, specificPendingBlockHash);\n      response.receiveMessage = `received ${sweepBlocks.length} blocks.`;\n      response.receiveCount = sweepBlocks.length;\n      response.receiveBlocks = sweepBlocks;\n    }\n  } else {\n    response.pendingMessage = `pending unknown blocks, of max ${MAX_ACCOUNTS_PENDING}.`;\n  }\n  /* istanbul ignore if */\n  if (LOG_SWEEP) {\n    loggingUtil.log('SUCCESS receive account', account);\n  }\n  return response;\n};\n\n\nconst sweep = async (loggingUtil, bananodeApi, privateKey, representative, specificPendingBlockHash) => {\n  /* istanbul ignore if */\n  if (LOG_SWEEP) {\n    loggingUtil.log('STARTED sweep');\n  }\n  const publicKey = bananoUtil.getPublicKey(privateKey);\n  const account = bananoUtil.getAccount(publicKey);\n  const accountsPending = await bananodeApi.getAccountsPending([account], MAX_ACCOUNTS_PENDING);\n  const history = await bananodeApi.getAccountHistory(account, 1);\n  const history_history = history.history;\n\n  /* istanbul ignore if */\n  if (LOG_SWEEP) {\n    loggingUtil.log(`INTERIM sweep accountsPending`, accountsPending);\n  }\n\n  const accountOpenAndReceiveBlocks = [];\n\n  /* istanbul ignore if */\n  if (LOG_SWEEP) {\n    loggingUtil.log(`INTERIM sweep history_history.length`, history_history.length);\n  }\n  if (history_history.length == 0) {\n    let isFirstPending = true;\n    const pendingBlockHashs = Object.keys(accountsPending.blocks[account]);\n    /* istanbul ignore if */\n    if (LOG_SWEEP) {\n      loggingUtil.log(`INTERIM sweep pendingBlockHashs`, pendingBlockHashs);\n    }\n    for (let pendingBlockHashIx = 0; pendingBlockHashIx < pendingBlockHashs.length; pendingBlockHashIx++) {\n      const pendingBlockHash = pendingBlockHashs[pendingBlockHashIx];\n      if ((specificPendingBlockHash == undefined) || specificPendingBlockHash == pendingBlockHash) {\n        const pendingValueRaw = accountsPending.blocks[account][pendingBlockHash];\n        if (isFirstPending) {\n          const pending = pendingBlockHash;\n          /* istanbul ignore if */\n          if (LOG_SWEEP) {\n            loggingUtil.log(`INTERIM STARTED sweep openBlockHash pending`, pending);\n          }\n          const openBlockHash = await bananoUtil.open(bananodeApi, privateKey, publicKey, account, pending, pendingValueRaw);\n          /* istanbul ignore if */\n          if (LOG_SWEEP) {\n            loggingUtil.log(`INTERIM SUCCESS sweep openBlockHash`, account, openBlockHash);\n          }\n          accountOpenAndReceiveBlocks.push(openBlockHash);\n          isFirstPending = false;\n        } else {\n          const frontiers = await bananodeApi.getFrontiers(account, 1);\n          const previous = frontiers.frontiers[account];\n          const hash = pendingBlockHash;\n          const valueRaw = pendingValueRaw;\n          const receiveBlockHash = await bananoUtil.receive(bananodeApi, privateKey, publicKey, representative, previous, hash, valueRaw);\n          /* istanbul ignore if */\n          if (LOG_SWEEP) {\n            loggingUtil.log(`INTERIM sweep receiveBlockHash`, account, receiveBlockHash);\n          }\n          accountOpenAndReceiveBlocks.push(receiveBlockHash);\n        }\n      }\n    }\n  } else {\n    const pendingBlockHashs = Object.keys(accountsPending.blocks[account]);\n    for (let pendingBlockHashIx = 0; pendingBlockHashIx < pendingBlockHashs.length; pendingBlockHashIx++) {\n      const pendingBlockHash = pendingBlockHashs[pendingBlockHashIx];\n      if ((specificPendingBlockHash == undefined) || specificPendingBlockHash == pendingBlockHash) {\n        const pendingValueRaw = accountsPending.blocks[account][pendingBlockHash];\n        const frontiers = await bananodeApi.getFrontiers(account, 1);\n        /* istanbul ignore if */\n        if (LOG_SWEEP) {\n          loggingUtil.log(`INTERIM sweep hasHistory frontiers`, frontiers);\n        }\n        const accountBalanceRaw = await bananodeApi.getAccountBalanceRaw(account);\n\n        const previous = frontiers.frontiers[account];\n        const hash = pendingBlockHash;\n        const valueRaw = (BigInt(pendingValueRaw) + BigInt(accountBalanceRaw)).toString();\n        const receiveBlockHash = await bananoUtil.receive(bananodeApi, privateKey, publicKey, representative, previous, hash, valueRaw);\n        /* istanbul ignore if */\n        if (LOG_SWEEP) {\n          loggingUtil.log(`INTERIM sweep hasHistory receiveBlockHash`, account, receiveBlockHash);\n        }\n        accountOpenAndReceiveBlocks.push(receiveBlockHash);\n      }\n    }\n    /* istanbul ignore if */\n    if (LOG_SWEEP) {\n      loggingUtil.log(`INTERIM sweep hasHistory`, account, history_history.length, accountsPending.blocks[account]);\n    }\n  }\n  /* istanbul ignore if */\n  if (LOG_SWEEP) {\n    loggingUtil.log('SUCCESS sweep', accountOpenAndReceiveBlocks);\n  }\n\n  return accountOpenAndReceiveBlocks;\n};\n\nexports.receive = receive;\n\n\n//# sourceURL=webpack:///./app/scripts/deposit-util.js?");

/***/ }),

/***/ "./app/scripts/logging-util.js":
/*!*************************************!*\
  !*** ./app/scripts/logging-util.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.log = console.log;\nexports.trace = console.trace;\n\n\n//# sourceURL=webpack:///./app/scripts/logging-util.js?");

/***/ }),

/***/ "./app/scripts/withdraw-util.js":
/*!**************************************!*\
  !*** ./app/scripts/withdraw-util.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst bananoUtil = __webpack_require__(/*! ./banano-util.js */ \"./app/scripts/banano-util.js\");\n\nconst LOG_WITHDRAW = false;\n\nconst withdraw = async (loggingUtil, bananodeApi, privateKey, toAccount, amountBananos) => {\n  /* istanbul ignore if */\n  if (loggingUtil === undefined) {\n    throw Error('loggingUtil is required.');\n  }\n  /* istanbul ignore if */\n  if (bananodeApi === undefined) {\n    throw Error('bananodeApi is required.');\n  }\n  /* istanbul ignore if */\n  if (privateKey === undefined) {\n    throw Error('privateKey is required.');\n  }\n  /* istanbul ignore if */\n  if (toAccount === undefined) {\n    throw Error('toAccount is required.');\n  }\n  /* istanbul ignore if */\n  if (amountBananos === undefined) {\n    throw Error('amountBananos is required.');\n  }\n  const publicKey = bananoUtil.getPublicKey(privateKey);\n  const fromAccount = bananoUtil.getAccount(publicKey);\n  const amountRaw = bananoUtil.getRawStrFromBananoStr(amountBananos.toString());\n  /* istanbul ignore if */\n  if (LOG_WITHDRAW) {\n    loggingUtil.log('STARTED withdraw fromAccount', fromAccount,\n        'toAccount', toAccount, 'amountRaw', amountRaw);\n  }\n  const response = await bananoUtil.sendFromPrivateKey(bananodeApi, privateKey, toAccount, amountRaw);\n  /* istanbul ignore if */\n  if (LOG_WITHDRAW) {\n    loggingUtil.log('SUCCESS withdraw fromAccount', fromAccount,\n        'toAccount', toAccount, 'amountRaw', amountRaw, 'response', response);\n  }\n  return response;\n};\n\nexports.withdraw = withdraw;\n\n\n//# sourceURL=webpack:///./app/scripts/withdraw-util.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst bananoUtil = __webpack_require__(/*! ./app/scripts/banano-util.js */ \"./app/scripts/banano-util.js\");\nconst realBananodeApi = __webpack_require__(/*! ./app/scripts/bananode-api.js */ \"./app/scripts/bananode-api.js\");\nconst camoUtil = __webpack_require__(/*! ./app/scripts/camo-util.js */ \"./app/scripts/camo-util.js\");\nconst depositUtil = __webpack_require__(/*! ./app/scripts/deposit-util.js */ \"./app/scripts/deposit-util.js\");\nconst withdrawUtil = __webpack_require__(/*! ./app/scripts/withdraw-util.js */ \"./app/scripts/withdraw-util.js\");\nconst loggingUtil = __webpack_require__(/*! ./app/scripts/logging-util.js */ \"./app/scripts/logging-util.js\");\n\nlet bananodeApi = realBananodeApi;\n\n/**\n * Sets the Bananode Api (useful for overriding some methods)\n * @memberof Main\n * @param {string} _bananodeApi the new bananodeApi\n * @return {undefined} returns nothing.\n */\nconst setBananodeApi = (_bananodeApi) => {\n  bananodeApi = _bananodeApi;\n};\n\n/**\n * Sends the amount to the account with an optional representative and\n * previous block hash.\n * If the representative is not sent, it will be pulled from the api.\n * If the previous is not sent, it will be pulled from the api.\n * Be very careful with previous, as setting it incorrectly\n * can cause an incorrect amount of funds to be sent.\n * @memberof BananoUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} destAccount the destination account.\n * @param {string} amountRaw the amount to send, in raw.\n * @param {string} representative the representative (optional).\n * @param {string} previousHash the previous hash (optional).\n * @return {string} returns the hash returned by the send.\n */\nconst sendAmountToAccountWithRepresentativeAndPrevious = async (seed, seedIx, destAccount, amountRaw, representative, previousHash) => {\n  const privateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const hash = await bananoUtil.sendFromPrivateKeyWithRepresentativeAndPrevious(bananodeApi, privateKey, destAccount, amountRaw, representative, previousHash);\n  return hash;\n};\n\n/**\n * Sends the amount to the account with a callback for success and failure.\n * @memberof BananoUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} destAccount the destination account.\n * @param {string} amountRaw the amount to send, in raw.\n * @param {string} successCallback the callback to call upon success.\n * @param {string} failureCallback the callback to call upon failure.\n * @return {string} returns the hash returned by the send.\n */\nconst sendAmountToAccount = async (seed, seedIx, destAccount, amountRaw, successCallback, failureCallback) => {\n  return await bananoUtil.send(bananodeApi, seed, seedIx, destAccount, amountRaw, successCallback, failureCallback)\n      .catch((error) => {\n        // console.trace(error);\n        throw Error(error);\n      });\n};\n\n/**\n * Sets the rep for an account with a given seed.\n * @memberof BananoUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} representative the representative.\n * @return {string} returns the hash returned by the change.\n */\nconst changeRepresentativeForSeed = async (seed, seedIx, representative) => {\n  const privateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const response = await bananoUtil.change(bananodeApi, privateKey, representative);\n  return response;\n};\n\n\n/**\n * Recieve deposits for an account with a given seed.\n * @memberof DepositUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} representative the representative.\n * @param {string} specificPendingBlockHash a specific block hash to receive (optional).\n * @return {object} returns the response returned by the receive.\n */\nconst receiveDepositsForSeed = async (seed, seedIx, representative, specificPendingBlockHash) => {\n  const privateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const publicKey = bananoUtil.getPublicKey(privateKey);\n  const account = bananoUtil.getAccount(publicKey);\n  const response = await depositUtil.receive(loggingUtil, bananodeApi, account, privateKey, representative, specificPendingBlockHash);\n  return response;\n};\n\n/**\n * Send a withdrawal from an account with a given seed.\n * @memberof WithdrawUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} toAccount the account to send to.\n * @param {string} amountBananos the amount of bananos.\n * @return {object} returns the response returned by the withdraw.\n */\nconst sendWithdrawalFromSeed = async (seed, seedIx, toAccount, amountBananos) => {\n  const privateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const response = withdrawUtil.withdraw(loggingUtil, bananodeApi, privateKey, toAccount, amountBananos);\n  return response;\n};\n\n/**\n * Get the balance, in raw, for an account.\n *\n * (use other methods like getBananoPartsFromRaw to convert to banano or banoshi)\n *\n * Calls {@link https://docs.nano.org/commands/rpc-protocol/#accounts_balances}\n * @memberof BananodeApi\n * @param {string} account the account to use.\n * @return {string} the account's balance, in raw.\n */\nconst getAccountBalanceRaw = async (account) => {\n  return await bananodeApi.getAccountBalanceRaw(account);\n};\n\n/**\n * Get the history for an account.\n *\n * Calls {@link https://docs.nano.org/commands/rpc-protocol/#account_history}\n * @memberof BananodeApi\n * @param {string} account the account to use.\n * @param {string} count the count to use (use -1 for all).\n * @param {string} head the head to start at (optional).\n * @param {string} raw if true, return raw history (optional).\n * @return {object} the account's history.\n */\nconst getAccountHistory = async (account, count, head, raw) => {\n  return await bananodeApi.getAccountHistory(account, count, head, raw);\n};\n\n\n/**\n * Get the account with a given seed and index.\n *\n * @memberof BananoUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @return {string} the account.\n */\nconst getAccountFromSeed = (seed, seedIx) => {\n  const privateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const publicKey = bananoUtil.getPublicKey(privateKey);\n  const account = bananoUtil.getAccount(publicKey);\n  return account;\n};\n\n/**\n * Sets the URL to use for the node behind the Bananode Api\n * @memberof Main\n * @param {string} url the new url\n * @return {undefined} returns nothing.\n */\nconst setBananodeApiUrl = (url) => {\n  bananodeApi.setUrl(url);\n};\n\n/**\n * Get the account info for an account.\n *\n * Calls {@link https://docs.nano.org/commands/rpc-protocol/#account_info}\n * @memberof BananodeApi\n * @param {string} account the account to use.\n * @param {boolean} representativeFlag the representativeFlag to use (optional).\n * @return {object} the account's info.\n */\nconst getAccountInfo = async (account, representativeFlag) => {\n  return await bananodeApi.getAccountInfo(account, representativeFlag);\n};\n\n/**\n * Get the network block count.\n *\n * Calls {@link https://docs.nano.org/commands/rpc-protocol/#block_count}\n * @memberof BananodeApi\n * @return {object} the block count.\n */\nconst getBlockCount = async () => {\n  return await bananodeApi.getBlockCount();\n};\n\n/**\n * Open an account with a given seed.\n * @memberof BananoUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} representative the representative.\n * @param {string} pendingBlockHash the pending block hash.\n * @param {string} pendingValueRaw the pending block hash.\n * @return {string} returns the hash returned by the open.\n */\nconst openAccountFromSeed = async (seed, seedIx, representative, pendingBlockHash, pendingValueRaw) => {\n  const privateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const publicKey = bananoUtil.getPublicKey(privateKey);\n  return await bananoUtil.open(bananodeApi, privateKey, publicKey, representative, pendingBlockHash, pendingValueRaw);\n};\n\n/**\n * Get the hash for a given block.\n *\n * @memberof BananoUtil\n * @param {string} block the seed to use to find the account.\n * @return {string} the block's hash.\n */\nconst getBlockHash = (block) => {\n  return bananoUtil.hash(block);\n};\n\n\n/**\n * Get the signature for a given block (gets the hash of the block, and signs the hash).\n *\n * @memberof BananoUtil\n * @param {string} privateKey the private key used to sign the block.\n * @param {string} block the block to sign.\n * @return {string} the block's signature.\n */\nconst getSignature = (privateKey, block) => {\n  return bananoUtil.sign(privateKey, block);\n};\n\n/**\n * Converts a hex string to bytes in a Uint8Array.\n *\n * @memberof BananoUtil\n * @param {string} hex the hex string to use.\n * @return {Uint8Array} the bytes in a Uint8Array.\n */\nconst getBytesFromHex = (hex) => {\n  return bananoUtil.hexToBytes(hex);\n};\n\n/**\n * gets work bytes using the CPU.\n *\n * @memberof BananoUtil\n * @param {string} hash the hash to use to calculate work bytes.\n * @param {Uint8Array} workBytes the Uint8Array(8) used to store temporary calculations.\n * @return {string} the work bytes as a hex string.\n */\nconst getWorkUsingCpu = (hash, workBytes) => {\n  return bananoUtil.getHashCPUWorker(hash, workBytes);\n};\n\n/**\n * receives funds at a camo address.\n *\n * @memberof CamoUtil\n * @param {string} toPrivateKey the private key that receives the funds.\n * @param {string} fromPublicKey the public key that sent the funds.\n * @return {string_array} the received hashes in an array.\n */\nconst camoReceive = async (toPrivateKey, fromPublicKey) => {\n  return await camoUtil.receive( bananodeApi, toPrivateKey, fromPublicKey );\n};\n\n/**\n * finds a new private key to recieve more funds. the key would have no history.\n *\n * @memberof CamoUtil\n * @param {string} seed the seed to use to find the account.\n * @return {string} the private key to use.\n */\nconst camoGetNextPrivateKeyForReceive = async (seed) => {\n  return await camoUtil.getFirstUnopenedPrivateKey( bananodeApi, seed );\n};\n\n/**\n * sends funds to a camo address.\n *\n * @memberof CamoUtil\n * @param {string} fundingPrivateKey the private key that sends the funds.\n * @param {string} fromCamoPrivateKey the private key used to generate the shared seed.\n * @param {string} toCamoPublicKey the public key that receives the funds.\n * @param {string} amountBananos the amount of bananos.\n * @return {string_array} the sent hashes in an array.\n */\nconst camoSend = async (fundingPrivateKey, fromCamoPrivateKey, toCamoPublicKey, amountBananos) => {\n  const amountRaw = bananoUtil.getRawStrFromBananoStr(amountBananos);\n  return await camoUtil.send( bananodeApi, fundingPrivateKey, fromCamoPrivateKey, toCamoPublicKey, amountRaw);\n};\n\n/**\n * sends funds to a camo account.\n * This function uses seed index 0 to generate the shared secret,\n * and seed index \"seedIx\" to get the private key that contains funds to send.\n *\n * @memberof CamoUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} toAccount the account to send to.\n * @param {string} amountBananos the amount of bananos.\n * @return {string_array} the sent hashes in an array.\n */\nconst camoSendWithdrawalFromSeed = async (seed, seedIx, toAccount, amountBananos) => {\n  const accountValid = getCamoAccountValidationInfo(toAccount);\n  if (!accountValid.valid) {\n    throw Error(accountValid.message);\n  }\n  const fundingPrivateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const fromCamoPrivateKey = bananoUtil.getPrivateKey(seed, 0);\n  const toCamoPublicKey = bananoUtil.getAccountPublicKey(toAccount);\n  return await camoSend( fundingPrivateKey, fromCamoPrivateKey, toCamoPublicKey, amountBananos);\n};\n\n/**\n * get the pending blocks for the camo account.\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} fromAccount the account to recieve from.\n * @param {number} count the max count to get.\n * @return {string_array} the pending hashes in an array.\n */\nconst camoGetAccountsPending = async (seed, seedIx, fromAccount, sharedSeedIx, count) => {\n  const accountValid = getCamoAccountValidationInfo(fromAccount);\n  if (!accountValid.valid) {\n    throw Error(accountValid.message);\n  }\n  const toPrivateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const fromPublicKey = bananoUtil.getAccountPublicKey(fromAccount);\n  return await camoUtil.getAccountsPending(bananodeApi, toPrivateKey, fromPublicKey, sharedSeedIx, count);\n};\n\n/**\n * returns data on whether a camo account is valid or not, and why.\n * @param {string} account the account to check.\n * @return {object} the account validity data.\n */\nconst getCamoAccountValidationInfo = (account) => {\n  const accountValid = camoUtil.isCamoAccountValid(account);\n  return accountValid;\n};\n\n/**\n * get the shared account, used as an intermediary to send finds between the seed and the camo account.\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} account the camo account to send or recieve from.\n * @param {string} sharedSeedIx the index to use with the shared seed.\n * @return {string} the shared account.\n */\nconst getCamoSharedAccountData = async (seed, seedIx, account, sharedSeedIx) => {\n  const accountValid = getCamoAccountValidationInfo(account);\n  if (!accountValid.valid) {\n    throw Error(accountValid.message);\n  }\n  const privateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const publicKey = bananoUtil.getAccountPublicKey(account);\n  return await camoUtil.getSharedAccountData(bananodeApi, privateKey, publicKey, sharedSeedIx);\n};\n\n\n/**\n* Recieve deposits for a camo account with a given seed.\n * @memberof CamoUtil\n * @param {string} seed the seed to use to find the account.\n * @param {string} seedIx the index to use with the seed.\n * @param {string} account the camo account to send or recieve from.\n * @param {string} sharedSeedIx the index to use with the shared seed.\n * @param {string} pendingBlockHash the pending block to recieve.\n * @return {string} the response from receiving the block.\n */\nconst receiveCamoDepositsForSeed = async (seed, seedIx, account, sharedSeedIx, specificPendingBlockHash) => {\n  const privateKey = bananoUtil.getPrivateKey(seed, seedIx);\n  const publicKey = bananoUtil.getAccountPublicKey(account);\n  const sharedSecret = await camoUtil.getSharedSecretFromRepresentative( bananodeApi, privateKey, publicKey );\n  if (sharedSecret) {\n    const sharedSeed = sharedSecret;\n    const privateKey = bananoUtil.getPrivateKey(sharedSeed, sharedSeedIx);\n    const camoPublicKey = await camoUtil.getCamoPublicKey(privateKey);\n    const camoRepresentative = await camoUtil.getCamoAccount(camoPublicKey);\n    const repPublicKey = await bananoUtil.getAccountPublicKey(camoRepresentative);\n    const representative = await bananoUtil.getAccount(repPublicKey);\n    const response = await receiveDepositsForSeed(sharedSeed, sharedSeedIx, representative, specificPendingBlockHash);\n    return response;\n  } else {\n    return undefined;\n  }\n};\n\n/**\n * gets the total account balance, in raw.\n *\n * @memberof CamoUtil\n * @param {string} toPrivateKey the private key that receives the funds.\n * @param {string} fromPublicKey the public key that sent the funds.\n * @return {string} the account balance, in raw.\n */\nconst getCamoAccountBalanceRaw = async (toPrivateKey, fromPublicKey) => {\n  return await camoUtil.getBalanceRaw( bananodeApi, toPrivateKey, fromPublicKey);\n};\n\n/**\n * Get the network block count.\n *\n * Calls {@link https://docs.nano.org/commands/rpc-protocol/#accounts_pending}\n * @memberof BananodeApi\n * @param {string_array} accounts the array of pending accounts.\n * @param {number} count the max count to get.\n * @param {string} source if true, get source.\n * @return {object} the account's pending blocks.\n */\nconst getAccountsPending = async (accounts, count, source) => {\n  return await bananodeApi.getAccountsPending(accounts, count, source);\n};\n\nmodule.exports.sendWithdrawalFromSeed = sendWithdrawalFromSeed;\nmodule.exports.getAccountsPending = getAccountsPending;\nmodule.exports.getAccountFromSeed = getAccountFromSeed;\nmodule.exports.getAccountInfo = getAccountInfo;\nmodule.exports.getBlockCount = getBlockCount;\n\nmodule.exports.bananoUtil = bananoUtil;\nmodule.exports.bananodeApi = bananodeApi;\nmodule.exports.camoUtil = camoUtil;\nmodule.exports.depositUtil = depositUtil;\nmodule.exports.withdrawUtil = withdrawUtil;\nmodule.exports.loggingUtil = loggingUtil;\n\nmodule.exports.setBananodeApi = setBananodeApi;\nmodule.exports.getAccountHistory = getAccountHistory;\nmodule.exports.openAccountFromSeed = openAccountFromSeed;\nmodule.exports.getBlockHash = getBlockHash;\nmodule.exports.getAccountBalanceRaw = getAccountBalanceRaw;\nmodule.exports.getBananoPartsFromRaw = bananoUtil.getBananoPartsFromRaw;\nmodule.exports.getPrivateKey = bananoUtil.getPrivateKey;\nmodule.exports.getPublicKey = bananoUtil.getPublicKey;\nmodule.exports.getAccount = bananoUtil.getAccount;\nmodule.exports.getAccountPublicKey = bananoUtil.getAccountPublicKey;\nmodule.exports.sendAmountToAccount = sendAmountToAccount;\nmodule.exports.sendAmountToAccountWithRepresentativeAndPrevious = sendAmountToAccountWithRepresentativeAndPrevious;\nmodule.exports.changeRepresentativeForSeed = changeRepresentativeForSeed;\nmodule.exports.getSignature = getSignature;\nmodule.exports.getBytesFromHex = getBytesFromHex;\nmodule.exports.getWorkUsingCpu = getWorkUsingCpu;\nmodule.exports.getZeroedWorkBytes = bananoUtil.getZeroedWorkBytes;\nmodule.exports.isWorkValid = bananoUtil.isWorkValid;\nmodule.exports.getAccountValidationInfo = bananoUtil.getAccountValidationInfo;\nmodule.exports.receiveDepositsForSeed = receiveDepositsForSeed;\nmodule.exports.getRawStrFromBananoStr = bananoUtil.getRawStrFromBananoStr;\nmodule.exports.getRawStrFromBanoshiStr = bananoUtil.getRawStrFromBanoshiStr;\nmodule.exports.setBananodeApiUrl = setBananodeApiUrl;\nmodule.exports.getCamoPublicKey = camoUtil.getCamoPublicKey;\nmodule.exports.getSharedSecret = camoUtil.getSharedSecret;\nmodule.exports.camoReceive = camoReceive;\nmodule.exports.camoSend = camoSend;\nmodule.exports.camoSendWithdrawalFromSeed = camoSendWithdrawalFromSeed;\nmodule.exports.getCamoAccount = camoUtil.getCamoAccount;\nmodule.exports.getCamoAccountBalanceRaw = getCamoAccountBalanceRaw;\nmodule.exports.camoGetNextPrivateKeyForReceive = camoGetNextPrivateKeyForReceive;\nmodule.exports.camoGetAccountsPending = camoGetAccountsPending;\nmodule.exports.getCamoSharedAccountData = getCamoSharedAccountData;\nmodule.exports.receiveCamoDepositsForSeed = receiveCamoDepositsForSeed;\nmodule.exports.getCamoAccountValidationInfo = getCamoAccountValidationInfo;\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./libraries/tweetnacl/nacl.js":
/*!*************************************!*\
  !*** ./libraries/tweetnacl/nacl.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst blake = __webpack_require__( /*! blakejs */ \"./node_modules/blakejs/index.js\" );\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetexports.cr.yp.to/\n\nvar u64 = function (h, l) {\n  this.hi = h | 0 >>> 0;\n  this.lo = l | 0 >>> 0;\n};\nvar gf = function (init) {\n  var i, r = new Float64Array(16);\n  if (init)\n    for (i = 0; i < init.length; i++)\n      r[i] = init[i];\n  return r;\n};\n\n// Pluggable, initialized in high-level API below.\nvar randombytes = function (/* x, n */) {\n  throw new Error('no PRNG');\n};\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32);\n_9[0] = 9;\n\nvar gf0 = gf(), gf1 = gf([ 1 ]), _121665 = gf([ 0xdb41, 1 ]), D = gf([ 0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079,\n    0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203 ]), D2 = gf([ 0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e,\n    0xfce7, 0x56df, 0xd9dc, 0x2406 ]), X = gf([ 0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e,\n    0x36d3, 0x2169 ]), Y = gf([ 0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666 ]), I = gf([\n    0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83 ]);\n\nfunction L32 (x, c) {\n  return (x << c) | (x >>> (32 - c));\n}\n\nfunction ld32 (x, i) {\n  var u = x[i + 3] & 0xff;\n  u = (u << 8) | (x[i + 2] & 0xff);\n  u = (u << 8) | (x[i + 1] & 0xff);\n  return (u << 8) | (x[i + 0] & 0xff);\n}\n\nfunction dl64 (x, i) {\n  var h = (x[i] << 24) | (x[i + 1] << 16) | (x[i + 2] << 8) | x[i + 3];\n  var l = (x[i + 4] << 24) | (x[i + 5] << 16) | (x[i + 6] << 8) | x[i + 7];\n  return new u64(h, l);\n}\n\nfunction st32 (x, j, u) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    x[j + i] = u & 255;\n    u >>>= 8;\n  }\n}\n\nfunction ts64 (x, i, u) {\n  x[i] = (u.hi >> 24) & 0xff;\n  x[i + 1] = (u.hi >> 16) & 0xff;\n  x[i + 2] = (u.hi >> 8) & 0xff;\n  x[i + 3] = u.hi & 0xff;\n  x[i + 4] = (u.lo >> 24) & 0xff;\n  x[i + 5] = (u.lo >> 16) & 0xff;\n  x[i + 6] = (u.lo >> 8) & 0xff;\n  x[i + 7] = u.lo & 0xff;\n}\n\nfunction vn (x, xi, y, yi, n) {\n  var i, d = 0;\n  for (i = 0; i < n; i++)\n    d |= x[xi + i] ^ y[yi + i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16 (x, xi, y, yi) {\n  return vn(x, xi, y, yi, 16);\n}\n\nfunction crypto_verify_32 (x, xi, y, yi) {\n  return vn(x, xi, y, yi, 32);\n}\n\nfunction core (out, inp, k, c, h) {\n  var w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t = new Uint32Array(4);\n  var i, j, m;\n\n  for (i = 0; i < 4; i++) {\n    x[5 * i] = ld32(c, 4 * i);\n    x[1 + i] = ld32(k, 4 * i);\n    x[6 + i] = ld32(inp, 4 * i);\n    x[11 + i] = ld32(k, 16 + 4 * i);\n  }\n\n  for (i = 0; i < 16; i++)\n    y[i] = x[i];\n\n  for (i = 0; i < 20; i++) {\n    for (j = 0; j < 4; j++) {\n      for (m = 0; m < 4; m++)\n        t[m] = x[(5 * j + 4 * m) % 16];\n      t[1] ^= L32((t[0] + t[3]) | 0, 7);\n      t[2] ^= L32((t[1] + t[0]) | 0, 9);\n      t[3] ^= L32((t[2] + t[1]) | 0, 13);\n      t[0] ^= L32((t[3] + t[2]) | 0, 18);\n      for (m = 0; m < 4; m++)\n        w[4 * j + (j + m) % 4] = t[m];\n    }\n    for (m = 0; m < 16; m++)\n      x[m] = w[m];\n  }\n\n  if (h) {\n    for (i = 0; i < 16; i++)\n      x[i] = (x[i] + y[i]) | 0;\n    for (i = 0; i < 4; i++) {\n      x[5 * i] = (x[5 * i] - ld32(c, 4 * i)) | 0;\n      x[6 + i] = (x[6 + i] - ld32(inp, 4 * i)) | 0;\n    }\n    for (i = 0; i < 4; i++) {\n      st32(out, 4 * i, x[5 * i]);\n      st32(out, 16 + 4 * i, x[6 + i]);\n    }\n  } else {\n    for (i = 0; i < 16; i++)\n      st32(out, 4 * i, (x[i] + y[i]) | 0);\n  }\n}\n\nfunction crypto_core_salsa20 (out, inp, k, c) {\n  core(out, inp, k, c, false);\n  return 0;\n}\n\nfunction crypto_core_hsalsa20 (out, inp, k, c) {\n  core(out, inp, k, c, true);\n  return 0;\n}\n\nvar sigma = new Uint8Array([ 101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107 ]);\n// \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor (c, cpos, m, mpos, b, n, k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  if (!b)\n    return 0;\n  for (i = 0; i < 16; i++)\n    z[i] = 0;\n  for (i = 0; i < 8; i++)\n    z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x, z, k, sigma);\n    for (i = 0; i < 64; i++)\n      c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    if (m)\n      mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x, z, k, sigma);\n    for (i = 0; i < b; i++)\n      c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20 (c, cpos, d, n, k) {\n  return crypto_stream_salsa20_xor(c, cpos, null, 0, d, n, k);\n}\n\nfunction crypto_stream (c, cpos, d, n, k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s, n, k, sigma);\n  return crypto_stream_salsa20(c, cpos, d, n.subarray(16), s);\n}\n\nfunction crypto_stream_xor (c, cpos, m, mpos, d, n, k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s, n, k, sigma);\n  return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);\n}\n\nfunction add1305 (h, c) {\n  var j, u = 0;\n  for (j = 0; j < 17; j++) {\n    u = (u + ((h[j] + c[j]) | 0)) | 0;\n    h[j] = u & 255;\n    u >>>= 8;\n  }\n}\n\nvar minusp = new Uint32Array([ 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252 ]);\n\nfunction crypto_onetimeauth (out, outpos, m, mpos, n, k) {\n  var s, i, j, u;\n  var x = new Uint32Array(17), r = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);\n  for (j = 0; j < 17; j++)\n    r[j] = h[j] = 0;\n  for (j = 0; j < 16; j++)\n    r[j] = k[j];\n  r[3] &= 15;\n  r[4] &= 252;\n  r[7] &= 15;\n  r[8] &= 252;\n  r[11] &= 15;\n  r[12] &= 252;\n  r[15] &= 15;\n\n  while (n > 0) {\n    for (j = 0; j < 17; j++)\n      c[j] = 0;\n    for (j = 0; (j < 16) && (j < n); ++j)\n      c[j] = m[mpos + j];\n    c[j] = 1;\n    mpos += j;\n    n -= j;\n    add1305(h, c);\n    for (i = 0; i < 17; i++) {\n      x[i] = 0;\n      for (j = 0; j < 17; j++)\n        x[i] = (x[i] + (h[j] * ((j <= i) ? r[i - j] : ((320 * r[i + 17 - j]) | 0))) | 0) | 0;\n    }\n    for (i = 0; i < 17; i++)\n      h[i] = x[i];\n    u = 0;\n    for (j = 0; j < 16; j++) {\n      u = (u + h[j]) | 0;\n      h[j] = u & 255;\n      u >>>= 8;\n    }\n    u = (u + h[16]) | 0;\n    h[16] = u & 3;\n    u = (5 * (u >>> 2)) | 0;\n    for (j = 0; j < 16; j++) {\n      u = (u + h[j]) | 0;\n      h[j] = u & 255;\n      u >>>= 8;\n    }\n    u = (u + h[16]) | 0;\n    h[16] = u;\n  }\n\n  for (j = 0; j < 17; j++)\n    g[j] = h[j];\n  add1305(h, minusp);\n  s = (-(h[16] >>> 7) | 0);\n  for (j = 0; j < 17; j++)\n    h[j] ^= s & (g[j] ^ h[j]);\n\n  for (j = 0; j < 16; j++)\n    c[j] = k[j + 16];\n  c[16] = 0;\n  add1305(h, c);\n  for (j = 0; j < 16; j++)\n    out[outpos + j] = h[j];\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify (h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x, 0, m, mpos, n, k);\n  return crypto_verify_16(h, hpos, x, 0);\n}\n\nfunction crypto_secretbox (c, m, d, n, k) {\n  var i;\n  if (d < 32)\n    return -1;\n  crypto_stream_xor(c, 0, m, 0, d, n, k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++)\n    c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open (m, c, d, n, k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32)\n    return -1;\n  crypto_stream(x, 0, 32, n, k);\n  if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)\n    return -1;\n  crypto_stream_xor(m, 0, c, 0, d, n, k);\n  for (i = 0; i < 32; i++)\n    m[i] = 0;\n  return 0;\n}\n\nfunction set25519 (r, a) {\n  var i;\n  for (i = 0; i < 16; i++)\n    r[i] = a[i] | 0;\n}\n\nfunction car25519 (o) {\n  var c;\n  var i;\n  for (i = 0; i < 16; i++) {\n    o[i] += 65536;\n    c = Math.floor(o[i] / 65536);\n    o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);\n    o[i] -= (c * 65536);\n  }\n}\n\nfunction sel25519 (p, q, b) {\n  var t, c = ~(b - 1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519 (o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++)\n    t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);\n      m[i - 1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);\n    b = (m[15] >> 16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1 - b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2 * i] = t[i] & 0xff;\n    o[2 * i + 1] = t[i] >> 8;\n  }\n}\n\nfunction neq25519 (a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519 (a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519 (o, n) {\n  var i;\n  for (i = 0; i < 16; i++)\n    o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A (o, a, b) {\n  var i;\n  for (i = 0; i < 16; i++)\n    o[i] = (a[i] + b[i]) | 0;\n}\n\nfunction Z (o, a, b) {\n  var i;\n  for (i = 0; i < 16; i++)\n    o[i] = (a[i] - b[i]) | 0;\n}\n\nfunction M (o, a, b) {\n  var i, j, t = new Float64Array(31);\n  for (i = 0; i < 31; i++)\n    t[i] = 0;\n  for (i = 0; i < 16; i++) {\n    for (j = 0; j < 16; j++) {\n      t[i + j] += a[i] * b[j];\n    }\n  }\n  for (i = 0; i < 15; i++) {\n    t[i] += 38 * t[i + 16];\n  }\n  for (i = 0; i < 16; i++)\n    o[i] = t[i];\n  car25519(o);\n  car25519(o);\n}\n\nfunction S (o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519 (o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++)\n    c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if (a !== 2 && a !== 4)\n      M(c, c, i);\n  }\n  for (a = 0; a < 16; a++)\n    o[a] = c[a];\n}\n\nfunction pow2523 (o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++)\n    c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n    S(c, c);\n    if (a !== 1)\n      M(c, c, i);\n  }\n  for (a = 0; a < 16; a++)\n    o[a] = c[a];\n}\n\nfunction crypto_scalarmult (q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++)\n    z[i] = n[i];\n  z[31] = (n[31] & 127) | 64;\n  z[0] &= 248;\n  unpack25519(x, p);\n  for (i = 0; i < 16; i++) {\n    b[i] = x[i];\n    d[i] = a[i] = c[i] = 0;\n  }\n  a[0] = d[0] = 1;\n  for (i = 254; i >= 0; --i) {\n    r = (z[i >>> 3] >>> (i & 7)) & 1;\n    sel25519(a, b, r);\n    sel25519(c, d, r);\n    A(e, a, c);\n    Z(a, a, c);\n    A(c, b, d);\n    Z(b, b, d);\n    S(d, e);\n    S(f, a);\n    M(a, c, a);\n    M(c, b, e);\n    A(e, a, c);\n    Z(a, a, c);\n    S(b, a);\n    Z(c, d, f);\n    M(a, c, _121665);\n    A(a, a, d);\n    M(c, c, a);\n    M(a, d, f);\n    M(d, b, x);\n    S(b, e);\n    sel25519(a, b, r);\n    sel25519(c, d, r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i + 16] = a[i];\n    x[i + 32] = c[i];\n    x[i + 48] = b[i];\n    x[i + 64] = d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32, x32);\n  M(x16, x16, x32);\n  pack25519(q, x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base (q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair (y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm (k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box (c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open (m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nfunction add64 () {\n  var a = 0, b = 0, c = 0, d = 0, m16 = 65535, l, h, i;\n  for (i = 0; i < arguments.length; i++) {\n    l = arguments[i].lo;\n    h = arguments[i].hi;\n    a += (l & m16);\n    b += (l >>> 16);\n    c += (h & m16);\n    d += (h >>> 16);\n  }\n\n  b += (a >>> 16);\n  c += (b >>> 16);\n  d += (c >>> 16);\n\n  return new u64((c & m16) | (d << 16), (a & m16) | (b << 16));\n}\n\nfunction shr64 (x, c) {\n  return new u64((x.hi >>> c), (x.lo >>> c) | (x.hi << (32 - c)));\n}\n\nfunction xor64 () {\n  var l = 0, h = 0, i;\n  for (i = 0; i < arguments.length; i++) {\n    l ^= arguments[i].lo;\n    h ^= arguments[i].hi;\n  }\n  return new u64(h, l);\n}\n\nfunction R (x, c) {\n  var h, l, c1 = 32 - c;\n  if (c < 32) {\n    h = (x.hi >>> c) | (x.lo << c1);\n    l = (x.lo >>> c) | (x.hi << c1);\n  } else if (c < 64) {\n    h = (x.lo >>> c) | (x.hi << c1);\n    l = (x.hi >>> c) | (x.lo << c1);\n  }\n  return new u64(h, l);\n}\n\nfunction Ch (x, y, z) {\n  var h = (x.hi & y.hi) ^ (~x.hi & z.hi), l = (x.lo & y.lo) ^ (~x.lo & z.lo);\n  return new u64(h, l);\n}\n\nfunction Maj (x, y, z) {\n  var h = (x.hi & y.hi) ^ (x.hi & z.hi) ^ (y.hi & z.hi), l = (x.lo & y.lo) ^ (x.lo & z.lo) ^ (y.lo & z.lo);\n  return new u64(h, l);\n}\n\nfunction Sigma0 (x) {\n  return xor64(R(x, 28), R(x, 34), R(x, 39));\n}\nfunction Sigma1 (x) {\n  return xor64(R(x, 14), R(x, 18), R(x, 41));\n}\nfunction sigma0 (x) {\n  return xor64(R(x, 1), R(x, 8), shr64(x, 7));\n}\nfunction sigma1 (x) {\n  return xor64(R(x, 19), R(x, 61), shr64(x, 6));\n}\n\nvar K = [ new u64(0x428a2f98, 0xd728ae22), new u64(0x71374491, 0x23ef65cd), new u64(0xb5c0fbcf, 0xec4d3b2f), new u64(0xe9b5dba5, 0x8189dbbc),\n    new u64(0x3956c25b, 0xf348b538), new u64(0x59f111f1, 0xb605d019), new u64(0x923f82a4, 0xaf194f9b), new u64(0xab1c5ed5, 0xda6d8118),\n    new u64(0xd807aa98, 0xa3030242), new u64(0x12835b01, 0x45706fbe), new u64(0x243185be, 0x4ee4b28c), new u64(0x550c7dc3, 0xd5ffb4e2),\n    new u64(0x72be5d74, 0xf27b896f), new u64(0x80deb1fe, 0x3b1696b1), new u64(0x9bdc06a7, 0x25c71235), new u64(0xc19bf174, 0xcf692694),\n    new u64(0xe49b69c1, 0x9ef14ad2), new u64(0xefbe4786, 0x384f25e3), new u64(0x0fc19dc6, 0x8b8cd5b5), new u64(0x240ca1cc, 0x77ac9c65),\n    new u64(0x2de92c6f, 0x592b0275), new u64(0x4a7484aa, 0x6ea6e483), new u64(0x5cb0a9dc, 0xbd41fbd4), new u64(0x76f988da, 0x831153b5),\n    new u64(0x983e5152, 0xee66dfab), new u64(0xa831c66d, 0x2db43210), new u64(0xb00327c8, 0x98fb213f), new u64(0xbf597fc7, 0xbeef0ee4),\n    new u64(0xc6e00bf3, 0x3da88fc2), new u64(0xd5a79147, 0x930aa725), new u64(0x06ca6351, 0xe003826f), new u64(0x14292967, 0x0a0e6e70),\n    new u64(0x27b70a85, 0x46d22ffc), new u64(0x2e1b2138, 0x5c26c926), new u64(0x4d2c6dfc, 0x5ac42aed), new u64(0x53380d13, 0x9d95b3df),\n    new u64(0x650a7354, 0x8baf63de), new u64(0x766a0abb, 0x3c77b2a8), new u64(0x81c2c92e, 0x47edaee6), new u64(0x92722c85, 0x1482353b),\n    new u64(0xa2bfe8a1, 0x4cf10364), new u64(0xa81a664b, 0xbc423001), new u64(0xc24b8b70, 0xd0f89791), new u64(0xc76c51a3, 0x0654be30),\n    new u64(0xd192e819, 0xd6ef5218), new u64(0xd6990624, 0x5565a910), new u64(0xf40e3585, 0x5771202a), new u64(0x106aa070, 0x32bbd1b8),\n    new u64(0x19a4c116, 0xb8d2d0c8), new u64(0x1e376c08, 0x5141ab53), new u64(0x2748774c, 0xdf8eeb99), new u64(0x34b0bcb5, 0xe19b48a8),\n    new u64(0x391c0cb3, 0xc5c95a63), new u64(0x4ed8aa4a, 0xe3418acb), new u64(0x5b9cca4f, 0x7763e373), new u64(0x682e6ff3, 0xd6b2b8a3),\n    new u64(0x748f82ee, 0x5defb2fc), new u64(0x78a5636f, 0x43172f60), new u64(0x84c87814, 0xa1f0ab72), new u64(0x8cc70208, 0x1a6439ec),\n    new u64(0x90befffa, 0x23631e28), new u64(0xa4506ceb, 0xde82bde9), new u64(0xbef9a3f7, 0xb2c67915), new u64(0xc67178f2, 0xe372532b),\n    new u64(0xca273ece, 0xea26619c), new u64(0xd186b8c7, 0x21c0c207), new u64(0xeada7dd6, 0xcde0eb1e), new u64(0xf57d4f7f, 0xee6ed178),\n    new u64(0x06f067aa, 0x72176fba), new u64(0x0a637dc5, 0xa2c898a6), new u64(0x113f9804, 0xbef90dae), new u64(0x1b710b35, 0x131c471b),\n    new u64(0x28db77f5, 0x23047d84), new u64(0x32caab7b, 0x40c72493), new u64(0x3c9ebe0a, 0x15c9bebc), new u64(0x431d67c4, 0x9c100d4c),\n    new u64(0x4cc5d4be, 0xcb3e42b6), new u64(0x597f299c, 0xfc657e2a), new u64(0x5fcb6fab, 0x3ad6faec), new u64(0x6c44198c, 0x4a475817) ];\n\nfunction crypto_hashblocks (x, m, n) {\n  var z = [], b = [], a = [], w = [], t, i, j;\n\n  for (i = 0; i < 8; i++)\n    z[i] = a[i] = dl64(x, 8 * i);\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++)\n      w[i] = dl64(m, 8 * i + pos);\n    for (i = 0; i < 80; i++) {\n      for (j = 0; j < 8; j++)\n        b[j] = a[j];\n      t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i % 16]);\n      b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));\n      b[3] = add64(b[3], t);\n      for (j = 0; j < 8; j++)\n        a[(j + 1) % 8] = b[j];\n      if (i % 16 === 15) {\n        for (j = 0; j < 16; j++) {\n          w[j] = add64(w[j], w[(j + 9) % 16], sigma0(w[(j + 1) % 16]), sigma1(w[(j + 14) % 16]));\n        }\n      }\n    }\n\n    for (i = 0; i < 8; i++) {\n      a[i] = add64(a[i], z[i]);\n      z[i] = a[i];\n    }\n\n    pos += 128;\n    n -= 128;\n  }\n\n  for (i = 0; i < 8; i++)\n    ts64(x, 8 * i, z[i]);\n  return n;\n}\n\nvar iv = new Uint8Array([ 0x6a, 0x09, 0xe6, 0x67, 0xf3, 0xbc, 0xc9, 0x08, 0xbb, 0x67, 0xae, 0x85, 0x84, 0xca, 0xa7, 0x3b, 0x3c, 0x6e, 0xf3, 0x72, 0xfe, 0x94,\n    0xf8, 0x2b, 0xa5, 0x4f, 0xf5, 0x3a, 0x5f, 0x1d, 0x36, 0xf1, 0x51, 0x0e, 0x52, 0x7f, 0xad, 0xe6, 0x82, 0xd1, 0x9b, 0x05, 0x68, 0x8c, 0x2b, 0x3e, 0x6c, 0x1f,\n    0x1f, 0x83, 0xd9, 0xab, 0xfb, 0x41, 0xbd, 0x6b, 0x5b, 0xe0, 0xcd, 0x19, 0x13, 0x7e, 0x21, 0x79 ]);\n\nfunction crypto_hash (out, m, n) {\n  var h = new Uint8Array(64), x = new Uint8Array(256);\n  var i, b = n;\n\n  for (i = 0; i < 64; i++)\n    h[i] = iv[i];\n\n  crypto_hashblocks(h, m, n);\n  n %= 128;\n\n  for (i = 0; i < 256; i++)\n    x[i] = 0;\n  for (i = 0; i < n; i++)\n    x[i] = m[b - n + i];\n  x[n] = 128;\n\n  n = 256 - 128 * (n < 112 ? 1 : 0);\n  x[n - 9] = 0;\n  ts64(x, n - 8, new u64((b / 0x20000000) | 0, b << 3));\n  crypto_hashblocks(h, x, n);\n\n  for (i = 0; i < 64; i++)\n    out[i] = h[i];\n\n  return 0;\n}\n\nfunction add (p, q) {\n  var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap (p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack (r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult (p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i / 8) | 0] >> (i & 7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase (p, s) {\n  var q = [ gf(), gf(), gf(), gf() ];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair (pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [ gf(), gf(), gf(), gf() ];\n  var i;\n\n  if (!seeded)\n    randombytes(sk, 32);\n\n  var context = blake.blake2bInit(64);\n  blake.blake2bUpdate(context, sk);\n  d = blake.blake2bFinal(context);\n\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  return 0;\n}\n\nconst hashSecret = ( sk ) => {\n    var d = new Uint8Array( 64 );\n    var pk = new Uint8Array( 32 );\n    var context = blake.blake2bInit( 64 );\n    blake.blake2bUpdate( context, sk );\n    d = blake.blake2bFinal( context );\n    return d;\n}\n\nexports.camo = {};\nexports.camo.hashsecret = hashSecret;\n\nexports.camo.scalarMult = function (n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES * 2)\n    throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES)\n    throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nexports.camo.scalarMult.base = function (n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES*2)\n    throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nexports.camo.scalarbase = deriveUnhashedPublicFromSecret;\n\nfunction deriveUnhashedPublicFromSecret (sk) {\n  var d = sk;\n  var p = [ gf(), gf(), gf(), gf() ];\n  var i;\n  var pk = new Uint8Array(32);\n\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n  return pk;\n}\n\nfunction derivePublicFromSecret (sk) {\n  var d = new Uint8Array(64);\n  var p = [ gf(), gf(), gf(), gf() ];\n  var i;\n  var pk = new Uint8Array(32);\n  var context = blake.blake2bInit(64);\n  blake.blake2bUpdate(context, sk);\n  d = blake.blake2bFinal(context);\n\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n  return pk;\n}\n\nvar L = new Float64Array([ 0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0x10 ]);\n\nfunction modL (r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = (x[j] + 128) >> 8;\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++)\n    x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i + 1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce (r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++)\n    x[i] = r[i];\n  for (i = 0; i < 64; i++)\n    r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign (sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [ gf(), gf(), gf(), gf() ];\n\n  var pk = derivePublicFromSecret(sk);\n\n  var context = blake.blake2bInit(64, null);\n  blake.blake2bUpdate(context, sk);\n  d = blake.blake2bFinal(context);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++)\n    sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++)\n    sm[32 + i] = d[32 + i];\n\n  context = blake.blake2bInit(64, null);\n  blake.blake2bUpdate(context, sm.subarray(32));\n  r = blake.blake2bFinal(context);\n\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++)\n    sm[i] = pk[i - 32];\n\n  context = blake.blake2bInit(64, null);\n  blake.blake2bUpdate(context, sm);\n  h = blake.blake2bFinal(context);\n\n  reduce(h);\n\n  for (i = 0; i < 64; i++)\n    x[i] = 0;\n  for (i = 0; i < 32; i++)\n    x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i + j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg (r, p) {\n  var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num))\n    M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num))\n    return -1;\n\n  if (par25519(r[0]) === (p[31] >> 7))\n    Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open (m, sm, n, pk) {\n  var i, mlen;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [ gf(), gf(), gf(), gf() ], q = [ gf(), gf(), gf(), gf() ];\n\n  mlen = -1;\n  if (n < 64)\n    return -1;\n\n  if (unpackneg(q, pk))\n    return -1;\n\n  for (i = 0; i < n; i++)\n    m[i] = sm[i];\n  for (i = 0; i < 32; i++)\n    m[i + 32] = pk[i];\n  // crypto_hash(h, m, n);\n\n  context = blake.blake2bInit(64, null);\n  blake.blake2bUpdate(context, m);\n  h = blake.blake2bFinal(context);\n\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++)\n      m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++)\n    m[i] = sm[i + 64];\n  mlen = n;\n  return mlen;\n}\n\nvar crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 32, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;\n\nexports.lowlevel = {\n  crypto_core_hsalsa20 : crypto_core_hsalsa20,\n  crypto_stream_xor : crypto_stream_xor,\n  crypto_stream : crypto_stream,\n  crypto_stream_salsa20_xor : crypto_stream_salsa20_xor,\n  crypto_stream_salsa20 : crypto_stream_salsa20,\n  crypto_onetimeauth : crypto_onetimeauth,\n  crypto_onetimeauth_verify : crypto_onetimeauth_verify,\n  crypto_verify_16 : crypto_verify_16,\n  crypto_verify_32 : crypto_verify_32,\n  crypto_secretbox : crypto_secretbox,\n  crypto_secretbox_open : crypto_secretbox_open,\n  crypto_scalarmult : crypto_scalarmult,\n  crypto_scalarmult_base : crypto_scalarmult_base,\n  crypto_box_beforenm : crypto_box_beforenm,\n  crypto_box_afternm : crypto_box_afternm,\n  crypto_box : crypto_box,\n  crypto_box_open : crypto_box_open,\n  crypto_box_keypair : crypto_box_keypair,\n  crypto_hash : crypto_hash,\n  crypto_sign : crypto_sign,\n  crypto_sign_keypair : crypto_sign_keypair,\n  crypto_sign_open : crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES : crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES : crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES : crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES : crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES : crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES : crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES : crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES : crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES : crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES : crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES : crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES : crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES : crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES : crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES : crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES : crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES : crypto_hash_BYTES\n};\n\n/* High-level API */\n\nfunction checkLengths (k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES)\n    throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES)\n    throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths (pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes () {\n  for (var i = 0; i < arguments.length; i++) {\n    if (!(arguments[i] instanceof Uint8Array))\n      throw new TypeError('unexpected type, use Uint8Array');\n  }\n}\n\nfunction cleanup (arr) {\n  for (var i = 0; i < arr.length; i++)\n    arr[i] = 0;\n}\n\nexports.randomBytes = function (n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nexports.secretbox = function (msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++)\n    m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nexports.secretbox.open = function (box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++)\n    c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32)\n    return null;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)\n    return null;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nexports.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nexports.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nexports.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nexports.scalarMult = function (n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES)\n    throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES)\n    throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nexports.scalarMult.base = function (n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES)\n    throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nexports.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nexports.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nexports.box = function (msg, nonce, publicKey, secretKey) {\n  var k = exports.box.before(publicKey, secretKey);\n  return exports.secretbox(msg, nonce, k);\n};\n\nexports.box.before = function (publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nexports.box.after = exports.secretbox;\n\nexports.box.open = function (msg, nonce, publicKey, secretKey) {\n  var k = exports.box.before(publicKey, secretKey);\n  return exports.secretbox.open(msg, nonce, k);\n};\n\nexports.box.open.after = exports.secretbox.open;\n\nexports.box.keyPair = function () {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {\n    publicKey : pk,\n    secretKey : sk\n  };\n};\n\nexports.box.keyPair.fromSecretKey = function (secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {\n    publicKey : pk,\n    secretKey : new Uint8Array(secretKey)\n  };\n};\n\nexports.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nexports.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nexports.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nexports.box.nonceLength = crypto_box_NONCEBYTES;\nexports.box.overheadLength = exports.secretbox.overheadLength;\n\nexports.sign = function (msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nexports.sign.open = function (signedMsg, publicKey) {\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0)\n    return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++)\n    m[i] = tmp[i];\n  return m;\n};\n\nexports.sign.detached = function (msg, secretKey) {\n  var signedMsg = exports.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++)\n    sig[i] = signedMsg[i];\n  return sig;\n};\n\nexports.sign.detached.verify = function (msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++)\n    sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++)\n    sm[i + crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nexports.sign.keyPair = function () {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {\n    publicKey : pk,\n    secretKey : sk\n  };\n};\n\nexports.sign.keyPair.fromUnhashedSecretKey = function (secretKey) {\n  checkArrayTypes(secretKey);\n// if (secretKey.length !== crypto_sign_SECRETKEYBYTES) {\n// throw new Error('bad secret key size');\n// }\n  return deriveUnhashedPublicFromSecret(secretKey);\n};\n\nexports.sign.keyPair.fromSecretKey = function (secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  pk = derivePublicFromSecret(secretKey);\n  return {\n    publicKey : pk,\n    secretKey : new Uint8Array(secretKey)\n  };\n};\n\nexports.sign.keyPair.fromSeed = function (seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++)\n    sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {\n    publicKey : pk,\n    secretKey : sk\n  };\n};\n\nexports.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nexports.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nexports.sign.seedLength = crypto_sign_SEEDBYTES;\nexports.sign.signatureLength = crypto_sign_BYTES;\n\nexports.hash = function (msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nexports.hash.hashLength = crypto_hash_BYTES;\n\nexports.verify = function (x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0)\n    return false;\n  if (x.length !== y.length)\n    return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nexports.setPRNG = function (fn) {\n  randombytes = fn;\n};\n\n(function () {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;\n  if (crypto && crypto.getRandomValues) {\n    // Browsers.\n    var QUOTA = 65536;\n    exports.setPRNG(function (x, n) {\n      var i, v = new Uint8Array(n);\n      for (i = 0; i < n; i += QUOTA) {\n        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n      }\n      for (i = 0; i < n; i++)\n        x[i] = v[i];\n      cleanup(v);\n    });\n  } else if (true) {\n    // Node.js.\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n    if (crypto && crypto.randomBytes) {\n      exports.setPRNG(function (x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++)\n          x[i] = v[i];\n        cleanup(v);\n      });\n    }\n  }\n})();\n\n//# sourceURL=webpack:///./libraries/tweetnacl/nacl.js?");

/***/ }),

/***/ "./node_modules/blakejs/blake2b.js":
/*!*****************************************!*\
  !*** ./node_modules/blakejs/blake2b.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Blake2B in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/blakejs/util.js\")\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += v[b,b+1]\n// v should be a Uint32Array\nfunction ADD64AA (v, a, b) {\n  var o0 = v[a] + v[b]\n  var o1 = v[a + 1] + v[b + 1]\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += b\n// b0 is the low 32 bits of b, b1 represents the high 32 bits\nfunction ADD64AC (v, a, b0, b1) {\n  var o0 = v[a] + b0\n  if (b0 < 0) {\n    o0 += 0x100000000\n  }\n  var o1 = v[a + 1] + b1\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// Little-endian byte access\nfunction B2B_GET32 (arr, i) {\n  return (arr[i] ^\n  (arr[i + 1] << 8) ^\n  (arr[i + 2] << 16) ^\n  (arr[i + 3] << 24))\n}\n\n// G Mixing function\n// The ROTRs are inlined for speed\nfunction B2B_G (a, b, c, d, ix, iy) {\n  var x0 = m[ix]\n  var x1 = m[ix + 1]\n  var y0 = m[iy]\n  var y1 = m[iy + 1]\n\n  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  var xor0 = v[d] ^ v[a]\n  var xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = xor1\n  v[d + 1] = xor0\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor0 >>> 24) ^ (xor1 << 8)\n  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)\n\n  ADD64AA(v, a, b)\n  ADD64AC(v, a, y0, y1)\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a]\n  xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = (xor0 >>> 16) ^ (xor1 << 16)\n  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor1 >>> 31) ^ (xor0 << 1)\n  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)\n}\n\n// Initialization Vector\nvar BLAKE2B_IV32 = new Uint32Array([\n  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,\n  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,\n  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,\n  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19\n])\n\nvar SIGMA8 = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3\n]\n\n// These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is Javascript and we don't have uint64s\nvar SIGMA82 = new Uint8Array(SIGMA8.map(function (x) { return x * 2 }))\n\n// Compression function. 'last' flag indicates last block.\n// Note we're representing 16 uint64s as 32 uint32s\nvar v = new Uint32Array(32)\nvar m = new Uint32Array(32)\nfunction blake2bCompress (ctx, last) {\n  var i = 0\n\n  // init work variables\n  for (i = 0; i < 16; i++) {\n    v[i] = ctx.h[i]\n    v[i + 16] = BLAKE2B_IV32[i]\n  }\n\n  // low 64 bits of offset\n  v[24] = v[24] ^ ctx.t\n  v[25] = v[25] ^ (ctx.t / 0x100000000)\n  // high 64 bits not supported, offset may not be higher than 2**53-1\n\n  // last block flag set ?\n  if (last) {\n    v[28] = ~v[28]\n    v[29] = ~v[29]\n  }\n\n  // get little-endian words\n  for (i = 0; i < 32; i++) {\n    m[i] = B2B_GET32(ctx.b, 4 * i)\n  }\n\n  // twelve rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 64)\n  for (i = 0; i < 12; i++) {\n    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)\n    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])\n    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])\n    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])\n    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])\n    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])\n    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])\n    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])\n    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])\n  }\n  // util.debugPrint('   (i=12) v[16]', v, 64)\n\n  for (i = 0; i < 16; i++) {\n    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]\n  }\n  // util.debugPrint('h[8]', ctx.h, 64)\n}\n\n// Creates a BLAKE2b hashing context\n// Requires an output length between 1 and 64 bytes\n// Takes an optional Uint8Array key\nfunction blake2bInit (outlen, key) {\n  if (outlen === 0 || outlen > 64) {\n    throw new Error('Illegal output length, expected 0 < length <= 64')\n  }\n  if (key && key.length > 64) {\n    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')\n  }\n\n  // state, 'param block'\n  var ctx = {\n    b: new Uint8Array(128),\n    h: new Uint32Array(16),\n    t: 0, // input count\n    c: 0, // pointer within buffer\n    outlen: outlen // output length in bytes\n  }\n\n  // initialize hash state\n  for (var i = 0; i < 16; i++) {\n    ctx.h[i] = BLAKE2B_IV32[i]\n  }\n  var keylen = key ? key.length : 0\n  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen\n\n  // key the hash, if applicable\n  if (key) {\n    blake2bUpdate(ctx, key)\n    // at the end\n    ctx.c = 128\n  }\n\n  return ctx\n}\n\n// Updates a BLAKE2b streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2bUpdate (ctx, input) {\n  for (var i = 0; i < input.length; i++) {\n    if (ctx.c === 128) { // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2bCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2b streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2bFinal (ctx) {\n  ctx.t += ctx.c // mark last block offset\n\n  while (ctx.c < 128) { // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2bCompress(ctx, true) // final block flag = 1\n\n  // little endian convert and store\n  var out = new Uint8Array(ctx.outlen)\n  for (var i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))\n  }\n  return out\n}\n\n// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2b (input, key, outlen) {\n  // preprocess inputs\n  outlen = outlen || 64\n  input = util.normalizeInput(input)\n\n  // do the math\n  var ctx = blake2bInit(outlen, key)\n  blake2bUpdate(ctx, input)\n  return blake2bFinal(ctx)\n}\n\n// Computes the BLAKE2B hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2bHex (input, key, outlen) {\n  var output = blake2b(input, key, outlen)\n  return util.toHex(output)\n}\n\nmodule.exports = {\n  blake2b: blake2b,\n  blake2bHex: blake2bHex,\n  blake2bInit: blake2bInit,\n  blake2bUpdate: blake2bUpdate,\n  blake2bFinal: blake2bFinal\n}\n\n\n//# sourceURL=webpack:///./node_modules/blakejs/blake2b.js?");

/***/ }),

/***/ "./node_modules/blakejs/blake2s.js":
/*!*****************************************!*\
  !*** ./node_modules/blakejs/blake2s.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// BLAKE2s hash function in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/blakejs/util.js\")\n\n// Little-endian byte access.\n// Expects a Uint8Array and an index\n// Returns the little-endian uint32 at v[i..i+3]\nfunction B2S_GET32 (v, i) {\n  return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)\n}\n\n// Mixing function G.\nfunction B2S_G (a, b, c, d, x, y) {\n  v[a] = v[a] + v[b] + x\n  v[d] = ROTR32(v[d] ^ v[a], 16)\n  v[c] = v[c] + v[d]\n  v[b] = ROTR32(v[b] ^ v[c], 12)\n  v[a] = v[a] + v[b] + y\n  v[d] = ROTR32(v[d] ^ v[a], 8)\n  v[c] = v[c] + v[d]\n  v[b] = ROTR32(v[b] ^ v[c], 7)\n}\n\n// 32-bit right rotation\n// x should be a uint32\n// y must be between 1 and 31, inclusive\nfunction ROTR32 (x, y) {\n  return (x >>> y) ^ (x << (32 - y))\n}\n\n// Initialization Vector.\nvar BLAKE2S_IV = new Uint32Array([\n  0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19])\n\nvar SIGMA = new Uint8Array([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0])\n\n// Compression function. \"last\" flag indicates last block\nvar v = new Uint32Array(16)\nvar m = new Uint32Array(16)\nfunction blake2sCompress (ctx, last) {\n  var i = 0\n  for (i = 0; i < 8; i++) { // init work variables\n    v[i] = ctx.h[i]\n    v[i + 8] = BLAKE2S_IV[i]\n  }\n\n  v[12] ^= ctx.t // low 32 bits of offset\n  v[13] ^= (ctx.t / 0x100000000) // high 32 bits\n  if (last) { // last block flag set ?\n    v[14] = ~v[14]\n  }\n\n  for (i = 0; i < 16; i++) { // get little-endian words\n    m[i] = B2S_GET32(ctx.b, 4 * i)\n  }\n\n  // ten rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 32)\n  for (i = 0; i < 10; i++) {\n    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)\n    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]])\n    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]])\n    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]])\n    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]])\n    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]])\n    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]])\n    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]])\n    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]])\n  }\n  // util.debugPrint('   (i=10) v[16]', v, 32)\n\n  for (i = 0; i < 8; i++) {\n    ctx.h[i] ^= v[i] ^ v[i + 8]\n  }\n  // util.debugPrint('h[8]', ctx.h, 32)\n}\n\n// Creates a BLAKE2s hashing context\n// Requires an output length between 1 and 32 bytes\n// Takes an optional Uint8Array key\nfunction blake2sInit (outlen, key) {\n  if (!(outlen > 0 && outlen <= 32)) {\n    throw new Error('Incorrect output length, should be in [1, 32]')\n  }\n  var keylen = key ? key.length : 0\n  if (key && !(keylen > 0 && keylen <= 32)) {\n    throw new Error('Incorrect key length, should be in [1, 32]')\n  }\n\n  var ctx = {\n    h: new Uint32Array(BLAKE2S_IV), // hash state\n    b: new Uint32Array(64), // input block\n    c: 0, // pointer within block\n    t: 0, // input count\n    outlen: outlen // output length in bytes\n  }\n  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen\n\n  if (keylen > 0) {\n    blake2sUpdate(ctx, key)\n    ctx.c = 64 // at the end\n  }\n\n  return ctx\n}\n\n// Updates a BLAKE2s streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2sUpdate (ctx, input) {\n  for (var i = 0; i < input.length; i++) {\n    if (ctx.c === 64) { // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2sCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2s streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2sFinal (ctx) {\n  ctx.t += ctx.c // mark last block offset\n  while (ctx.c < 64) { // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2sCompress(ctx, true) // final block flag = 1\n\n  // little endian convert and store\n  var out = new Uint8Array(ctx.outlen)\n  for (var i = 0; i < ctx.outlen; i++) {\n    out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xFF\n  }\n  return out\n}\n\n// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 32 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2s (input, key, outlen) {\n  // preprocess inputs\n  outlen = outlen || 32\n  input = util.normalizeInput(input)\n\n  // do the math\n  var ctx = blake2sInit(outlen, key)\n  blake2sUpdate(ctx, input)\n  return blake2sFinal(ctx)\n}\n\n// Computes the BLAKE2S hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 32 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2sHex (input, key, outlen) {\n  var output = blake2s(input, key, outlen)\n  return util.toHex(output)\n}\n\nmodule.exports = {\n  blake2s: blake2s,\n  blake2sHex: blake2sHex,\n  blake2sInit: blake2sInit,\n  blake2sUpdate: blake2sUpdate,\n  blake2sFinal: blake2sFinal\n}\n\n\n//# sourceURL=webpack:///./node_modules/blakejs/blake2s.js?");

/***/ }),

/***/ "./node_modules/blakejs/index.js":
/*!***************************************!*\
  !*** ./node_modules/blakejs/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var b2b = __webpack_require__(/*! ./blake2b */ \"./node_modules/blakejs/blake2b.js\")\nvar b2s = __webpack_require__(/*! ./blake2s */ \"./node_modules/blakejs/blake2s.js\")\n\nmodule.exports = {\n  blake2b: b2b.blake2b,\n  blake2bHex: b2b.blake2bHex,\n  blake2bInit: b2b.blake2bInit,\n  blake2bUpdate: b2b.blake2bUpdate,\n  blake2bFinal: b2b.blake2bFinal,\n  blake2s: b2s.blake2s,\n  blake2sHex: b2s.blake2sHex,\n  blake2sInit: b2s.blake2sInit,\n  blake2sUpdate: b2s.blake2sUpdate,\n  blake2sFinal: b2s.blake2sFinal\n}\n\n\n//# sourceURL=webpack:///./node_modules/blakejs/index.js?");

/***/ }),

/***/ "./node_modules/blakejs/util.js":
/*!**************************************!*\
  !*** ./node_modules/blakejs/util.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'\n\n// For convenience, let people hash a string, not just a Uint8Array\nfunction normalizeInput (input) {\n  var ret\n  if (input instanceof Uint8Array) {\n    ret = input\n  } else if (input instanceof Buffer) {\n    ret = new Uint8Array(input)\n  } else if (typeof (input) === 'string') {\n    ret = new Uint8Array(Buffer.from(input, 'utf8'))\n  } else {\n    throw new Error(ERROR_MSG_INPUT)\n  }\n  return ret\n}\n\n// Converts a Uint8Array to a hexadecimal string\n// For example, toHex([255, 0, 255]) returns \"ff00ff\"\nfunction toHex (bytes) {\n  return Array.prototype.map.call(bytes, function (n) {\n    return (n < 16 ? '0' : '') + n.toString(16)\n  }).join('')\n}\n\n// Converts any value in [0...2^32-1] to an 8-character hex string\nfunction uint32ToHex (val) {\n  return (0x100000000 + val).toString(16).substring(1)\n}\n\n// For debugging: prints out hash state in the same format as the RFC\n// sample computation exactly, so that you can diff\nfunction debugPrint (label, arr, size) {\n  var msg = '\\n' + label + ' = '\n  for (var i = 0; i < arr.length; i += 2) {\n    if (size === 32) {\n      msg += uint32ToHex(arr[i]).toUpperCase()\n      msg += ' '\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n    } else if (size === 64) {\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n      msg += uint32ToHex(arr[i]).toUpperCase()\n    } else throw new Error('Invalid size ' + size)\n    if (i % 6 === 4) {\n      msg += '\\n' + new Array(label.length + 4).join(' ')\n    } else if (i < arr.length - 2) {\n      msg += ' '\n    }\n  }\n  console.log(msg)\n}\n\n// For performance testing: generates N bytes of input, hashes M times\n// Measures and prints MB/second hash performance each time\nfunction testSpeed (hashFn, N, M) {\n  var startMs = new Date().getTime()\n\n  var input = new Uint8Array(N)\n  for (var i = 0; i < N; i++) {\n    input[i] = i % 256\n  }\n  var genMs = new Date().getTime()\n  console.log('Generated random input in ' + (genMs - startMs) + 'ms')\n  startMs = genMs\n\n  for (i = 0; i < M; i++) {\n    var hashHex = hashFn(input)\n    var hashMs = new Date().getTime()\n    var ms = hashMs - startMs\n    startMs = hashMs\n    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')\n    console.log(Math.round(N / (1 << 20) / (ms / 1000) * 100) / 100 + ' MB PER SECOND')\n  }\n}\n\nmodule.exports = {\n  normalizeInput: normalizeInput,\n  toHex: toHex,\n  debugPrint: debugPrint,\n  testSpeed: testSpeed\n}\n\n\n//# sourceURL=webpack:///./node_modules/blakejs/util.js?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }),

/***/ "request":
/*!**************************!*\
  !*** external "request" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"request\");\n\n//# sourceURL=webpack:///external_%22request%22?");

/***/ })

/******/ });